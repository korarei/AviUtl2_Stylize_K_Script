@Saturate
--infomation:Saturate${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:R Gain,0,1000,100,0.01
--track1:G Gain,0,1000,100,0.01
--track2:B Gain,0,1000,100,0.01
--track3:A Gain,0,1000,100,0.01
--select@_1:Color Space=1,Linear=0,sRGB=1
--track@_2:Mix,0,100,100,0.01
--[[pixelshader@saturate:
${SHADER_UTILS}
${SHADER_SATURATE}
]]

local r_gain = obj.track0 * 0.01
local g_gain = obj.track1 * 0.01
local b_gain = obj.track2 * 0.01
local a_gain = obj.track3 * 0.01
local col_space = _1 _1 = nil
local mix = _2 * 0.01 _2 = nil

obj.pixelshader("saturate", "object", "object", {
    r_gain, g_gain, b_gain, a_gain,
    col_space,
    mix
})


@Mosaic
--infomation:Mosaic${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:X Blocks,1,16384,32,1
--track1:Y Blocks,1,16384,32,1
--check0:Sharp Colors,0
--value@_0:PI,{}
--[[computeshader@mosaic_ave:
${SHADER_MOSAIC_AVE}
]]
--[[pixelshader@mosaic_draw:
${SHADER_MOSAIC_DRAW}
]]
--[[pixelshader@mosaic_point:
${SHADER_MOSAIC_POINT}
]]

_0 = _0 or {}
local bx = math.floor(tonumber(_0.bx) or obj.track0)
local by = math.floor(tonumber(_0.by) or obj.track1)
local sharp_col = obj.check0
if (type(_0.sharp_col) == "boolean") then
    sharp_col = _0.sharp_col
elseif (type(_0.sharp_col) == "number") then
    sharp_col = _0.sharp_col ~= 0
end
_0 = nil

local function err_handler(e)
    local hint = "Hint: Try increasing TemporaryImageCacheSize in system.conf."
    debug_print(string.format("%s. %s", e, hint))
end

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

local ok, e = pcall(function()
local w, h = obj.getpixel()
bx = clamp(bx, 1, w)
by = clamp(by, 1, h)

if (sharp_col) then
    obj.pixelshader("mosaic_point", "object", "object", {
        bx, by,
        w, h
    })
else
    local n = 256
    obj.setoption("drawtarget", "tempbuffer", bx, by)
    obj.computeshader("mosaic_ave", "tempbuffer", "object", {
        bx, by,
        w, h,
        n,
        bx * by
    },
    n, 1, 1)

    obj.pixelshader("mosaic_draw", "object", "tempbuffer", {
        bx, by,
        w, h
    })

    obj.clearbuffer("tempbuffer")
end
end)
if (not ok) then
    err_handler(e)
end


@Threshold
--infomation:Threshold${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:Threshold,0,255,128
--select@_1:Channel=1,Luminance (BT.601)=0,Luminance (BT.709)=1,Luminance (BT.2020)=2,Value=3,Saturation=4,Hue=5,Alpha=6
--check0:Invert,0
--color@_2:Light Color,0xffffff
--track2:Light Alpha,0,100,100,0.01
--color@_3:Dark Color,0x000000
--track3:Dark Alpha,0,100,100,0.01
--select@_4:Color Space=1,Linear=0,sRGB=1
--track1:Mix,0,100,100,0.01
--[[pixelshader@thresholding:
${SHADER_UTILS}
${SHADER_THRESHOLD}
]]

local threshold = obj.track0 / 255.0
local channel = _1 _1 = nil
local inv = obj.check0
local light_col = _2 _2 = nil
local light_a = obj.track2 * 0.01
local dark_col = _3 _3 = nil
local dark_a = obj.track3 * 0.01
local col_space = _4 _4 = nil
local mix = obj.track1 * 0.01


obj.pixelshader("thresholding", "object", "object", {
    threshold,
    channel,
    inv and 1.0 or 0.0,
    light_col,
    light_a,
    dark_col,
    dark_a,
    col_space,
    mix
})


@Threshold(RGBA)
--infomation:Threshold(RGBA)${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:R Threshold,0,255,128
--track1:G Threshold,0,255,128
--track2:B Threshold,0,255,128
--track3:A Threshold,0,255,128
--check@_1:Invert R,0
--check@_2:Invert G,0
--check@_3:Invert B,0
--check@_4:Invert A,0
--check0:Disable A Threshold,0
--select@_5:Color Space=1,Linear=0,sRGB=1
--track@_6:Mix,0,100,100,0.01
--[[pixelshader@thresholding_rgba:
${SHADER_UTILS}
${SHADER_THRESHOLD_RGBA}
]]

local r_threshold = obj.track0 / 255.0
local g_threshold = obj.track1 / 255.0
local b_threshold = obj.track2 / 255.0
local a_threshold = obj.track3 / 255.0
local inv_r = _1 _1 = nil
local inv_g = _2 _2 = nil
local inv_b = _3 _3 = nil
local inv_a = _4 _4 = nil
local disable_a = obj.check0
local col_space = _5 _5 = nil
local mix = _6 * 0.01 _6 = nil


obj.pixelshader("thresholding_rgba", "object", "object", {
    r_threshold, g_threshold, b_threshold, a_threshold,
    inv_r, inv_g, inv_b, inv_a,
    disable_a and 1.0 or 0.0,
    col_space,
    mix
})


@Posterize
--infomation:Posterize${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:Level,2,256,8,1
--check@_1:Value Only,0
--track@_2:Size,1,2000,1,1
--check@_5:Sharp Colors,0
--check0:Multi Channel Mode,0
--track1:R Level,2,256,8,1
--track2:G Level,2,256,8,1
--track3:B Level,2,256,8,1
--select@_3:Color Space=1,Linear=0,sRGB=1
--track@_4:Mix,0,100,100,0.01
--[[pixelshader@posterize:
${SHADER_UTILS}
${SHADER_POSTERIZE}
]]

local level = math.floor(obj.track0)
local use_value = _1 _1 = nil
local size = math.floor(_2) _2 = nil
local sharp_col = _5 _5 = nil
local multi_channel_mode = obj.check0
local r_level = obj.track1
local g_level = obj.track2
local b_level = obj.track3
local col_space = _3 _3 = nil
local mix = _4 * 0.01 _4 = nil

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

if (size > 1) then
    local w, h = obj.getpixel()
    local mosaic_params = string.format("bx = %d, by = %d, sharp_col = %d", w / size, h / size, sharp_col)
    obj.effect("Mosaic@Stylize_K", "PI", mosaic_params)
end
obj.pixelshader("posterize", "object", "object", {
    multi_channel_mode and 1.0 or 0.0,
    clamp(r_level, 2, 256), clamp(g_level, 2, 256), clamp(b_level, 2, 256),
    clamp(level, 2, 256),
    use_value,
    col_space,
    mix
})


@ASCII
--infomation:ASCII${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--value@_1:Glyphs,"@#%*+=-:. "
--font@_2:Font,Yu Gothic UI
--track@_3:Padding,-100,100,0,1
--track0:X Blocks,1,16384,80,1
--track1:Y Blocks,1,16384,45,1
--check0:Sharp Colors,0
--track@_4:Luma Gain,0,1000,100,0.01
--track2:Min Luma,0,100,0,0.01
--track3:Max Luma,0,100,100,0.01
--select@_5:Luma Mode=1,BT.601=0,BT.709=1,BT.2020=2
--check@_6:Invert Luma,0
--select@_7:Glyph Type=0,Solid=0,Original=1,Mosaic=2
--color@_8:Glyph Color,0x0000000
--select@_9:Canvas Type=1,Transparent=0,Solid=1,Original=2,Mosaic=3
--color@_10:Canvas Color,0xffffff
--select@_11:Color Space=1,Linear=0,sRGB=1
--select@_12:Blend Mode,Normal=0,Add=1,Subtract=2,Multiply=3,Screen=4,Overlay=5,Lighten=6,Darken=7,Luminosity=8,Chroma=9,Linear Burn=10,Linear Light=11,Difference=12
--track@_13:Mix,0,100,100,0.01
--check@_14:Shuffle Glyphs,0
--track@_15:Interval,0,100,0,1
--track@_16:Seed,-1000,1000,-1,1
--value@_0:PI,{}
--[[pixelshader@ascii:
${SHADER_UTILS}
${SHADER_ASCII}
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local glyphs_str = _0.glyphs and tostring(_0.glyphs) or _1 _1 = nil
local font = _0.font and tostring(_0.font) or _2 _2 = nil
local padding = math.floor(tonumber(_0.padding) or _3) _3 = nil
local bx = clamp(math.floor(tonumber(_0.bx) or obj.track0), 1, 16384)
local by = clamp(math.floor(tonumber(_0.by) or obj.track1), 1, 16384)
local sharp_col = obj.check0 and 1 or 0
if (type(_0.sharp_col) == "boolean") then
    sharp_col = _0.sharp_col and 1 or 0
elseif (type(_0.sharp_col) == "number") then
    sharp_col = _0.sharp_col ~= 0 and 1 or 0
end
local luma_gain = math.max(tonumber(_0.luma_gain) or _4, 0.0) * 0.01 _4 = nil
local min_luma = clamp(tonumber(_0.min_luma) or obj.track2, 0.0, 100.0) * 0.01
local max_luma = clamp(tonumber(_0.max_luma) or obj.track3, 0.0, 100.0) * 0.01
local luma_mode = tonumber(_0.luma_mode) or _5 _5 = nil
local inv_luma = _6 _6 = nil
if (type(_0.inv_luma) == "boolean") then
    inv_luma = _0.inv_luma and 1 or 0
elseif (type(_0.inv_luma) == "number") then
    inv_luma = _0.inv_luma ~= 0 and 1 or 0
end
local glyph_type = tonumber(_0.glyph_type) or _7 _7 = nil
local glyph_col = clamp(tonumber(_0.glyph_col) or _8, 0x000000, 0xffffff) _8 = nil
local canvas_type = tonumber(_0.canvas_type) or _9 _9 = nil
local canvas_col = clamp(tonumber(_0.canvas_col) or _10, 0x000000, 0xffffff) _10 = nil
local col_space = tonumber(_0.col_space) or _11 _11 = nil
local blend_mode = tonumber(_0.blend_mode) or _12 _12= nil
local mix = clamp(tonumber(_0.mix) or _13, 0.0, 100.0) * 0.01 _13 = nil
local shuf_glyphs = _14 ~= 0 _14 = nil
if (type(_0.shuf_glyphs) == "boolean") then
    shuf_glyphs = _0.shuf_glyphs
elseif (type(_0.shuf_glyphs) == "number") then
    shuf_glyphs = _0.inv_luma ~= 0
end
local interval = math.max(tonumber(_0.interval) or _15, 0) _15 = nil
local seed = tonumber(_0.seed) or _16 _16 = nil
_0 = nil

if (glyphs_str == "") then
    debug_print("The text cannot be empty.")
    return
end

local function err_handler(e)
    local hint = "Hint: Try increasing TemporaryImageCacheSize in system.conf."
    debug_print(string.format("%s. %s", e, hint))
end

local function copy_geo(dst, src)
    for k in ("ox, oy, oz, cx, cy, cz, rx, ry, rz, zoom, aspect, alpha"):gmatch("%a+") do
        dst[k] = src[k]
    end
end

local function split_utf8(str)
    local t = {}
    local i = 1
    while i <= #str do
        local byte = string.byte(str, i)
        local len

        if byte < 0x80 then
            len = 1
        elseif byte < 0xE0 then
            len = 2
        elseif byte < 0xF0 then
            len = 3
        else
            len = 4
        end

        table.insert(t, string.sub(str, i, i + len - 1))
        i = i + len
    end
    return t
end

local function shuffle(t)
    local f = interval > 0 and math.floor(obj.frame / interval) or 0
    for i = #t, 2, -1 do
        local j = obj.rand(1, i, seed, f)
        t[i], t[j] = t[j], t[i]
    end
end

local ok, e = pcall(function()
    local geo = {}
    local blend = glyph_type == 1 and "mask" or "copy"
    local col_list = {0xff0000, 0x00ff00, 0x0000ff}
    local w, h = obj.getpixel()
    local max_w, max_h = obj.getinfo("image_max")
    local bw, bh = math.floor(w / bx), math.floor(h / by)
    local mosaic_params = string.format("bx = %d, by = %d, sharp_col = %d", bx, by, sharp_col)
    local size = math.max(math.min(bw, bh) - padding * 2, 0)
    local glyphs = split_utf8(glyphs_str)
    local len = #glyphs
    local map_w, map_h = bw * math.ceil(len / 3.0), bh
    if (map_w > max_w or map_h > max_h) then
        debug_print("The font size is too large or the text is too long.")
        return
    end

    copy_geo(geo, obj)
    obj.copybuffer("cache:img", "object")
    obj.effect("Mosaic@Stylize_K", "PI", mosaic_params)
    obj.copybuffer("cache:mosaic", "object")

    obj.setoption("drawtarget", "tempbuffer", map_w, map_h)
    obj.setoption("blend", 1)
    if (shuf_glyphs) then
        shuffle(glyphs)
    end

    local a = -0.5 * (map_w - bw)
    for i = 1, len do
        local idx = i - 1
        obj.setfont(font, size, 0, col_list[(idx % 3) + 1])
        obj.load("text", glyphs[i])
        obj.draw(a + bw * (math.floor(idx / 3)))
    end

    obj.copybuffer("object", "cache:img")
    obj.pixelshader("ascii", "object", {
        "cache:mosaic",
        "tempbuffer"
    }, {
        bx, by,
        w, h,
        map_w, map_h,
        min_luma, max_luma,
        len,
        luma_gain,
        luma_mode,
        inv_luma,
        glyph_type,
        glyph_col,
        col_space
    }, blend)

    if (canvas_type == 1) then
        obj.setoption("drawtarget", "tempbuffer", w, h)
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")

        obj.copybuffer("cache:ascii", "object")
        obj.load("figure", "四角形", canvas_col, 1)
        local half_w, half_h = w * 0.5, h * 0.5
        obj.drawpoly(
            -half_w, -half_h, 0,
            half_w,  -half_h, 0,
            half_w,  half_h,  0,
            -half_w, half_h,  0
        )
        obj.copybuffer("object", "cache:ascii")
    elseif (canvas_type == 2) then
        obj.copybuffer("tempbuffer", "cache:img")
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")
    elseif (canvas_type == 3) then
        obj.copybuffer("tempbuffer", "cache:mosaic")
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")
    else
        obj.setoption("drawtarget", "tempbuffer", w, h)
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")
    end

    obj.setoption("blend", blend_mode)
    obj.draw(0, 0, 0, 1, mix)
    obj.setoption("blend", 0)

    obj.load("tempbuffer")
    obj.clearbuffer("tempbuffer")
    copy_geo(obj, geo)
end)
if (not ok) then
    err_handler(e)
end


@MotionTile
--infomation:MotionTile${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:X Center,-4000,4000,0,0.01
--track1:Y Center,-4000,4000,0,0.01
--track2:Output W,0,1000,100,0.01
--track3:Output H,0,1000,100,0.01
--track@_1:Tile W,0,1000,100,0.01
--track@_2:Tile H,0,1000,100,0.01
--check@_3:Mirror Horizontal Edge,0
--check@_4:Mirror Vertical Edge,0
--track@_5:Phase,-3600,3600,0,0.01
--check0:Horizontal Shift,0
--[[pixelshader@motion_tile:
${SHADER_MOTION_TILE}
]]

obj.setanchor("track", 0, "line")

local w, h = obj.getpixel()

local cx = obj.track0 / w
local cy = obj.track1 / h
local out_w = obj.track2 * 0.01
local out_h = obj.track3 * 0.01
local tile_w = _1 * 0.01 _1 = nil
local tile_h = _2 * 0.01 _2 = nil
local mirror_h = _3 _3 = nil
local mirror_v = _4 _4 = nil
local phase = _5 / 360.0 _5 = nil
local h_shift = obj.check0

local geo = {}
local max_w, max_h = obj.getinfo("image_max")
local out_res_w = math.min(math.floor(w * out_w), max_w)
local out_res_h = math.min(math.floor(h * out_h), max_h)


local function err_handler(e)
    local hint = "Hint: Try increasing TemporaryImageCacheSize in system.conf."
    debug_print(string.format("%s. %s", e, hint))
end

local function copy_geo(dst, src)
    for k in ("ox, oy, oz, cx, cy, cz, rx, ry, rz, zoom, aspect, alpha"):gmatch("%a+") do
        dst[k] = src[k]
    end
end


if (out_res_w * out_res_h < 1) then
    obj.effect("リサイズ", "拡大率", 0)
    return
end

out_w = out_res_w / w
out_h = out_res_h / h

local ok, e = pcall(function()
copy_geo(geo, obj)
obj.setoption("drawtarget", "tempbuffer", out_res_w, out_res_h)

obj.pixelshader("motion_tile", "tempbuffer", "object", {
    w, h,
    cx, cy,
    out_w, out_h,
    tile_w, tile_h,
    mirror_h, mirror_v,
    phase,
    h_shift and 1.0 or 0.0
})

obj.load("tempbuffer")
obj.clearbuffer("tempbuffer")
copy_geo(obj, geo)
end)
if (not ok) then
    err_handler(e)
end


@Tile
--infomation:Tile${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:X Count,1,100,3,1
--track1:Y Count,1,100,3,1
--track@_1:Z Count,1,100,1,1
--track2:X Gap,0,1000,100,0.01
--track3:Y Gap,0,1000,100,0.01
--track@_2:Z Gap,0,1000,100,0.01
--value@_3:Z Size,math.max(obj.getpixel())
--check0:Use Group Pivot,1

local use_group_pivot = obj.check0

local count = {
    x = math.floor(obj.track0) - 1,
    y = math.floor(obj.track1) - 1,
    z = math.floor(_1) - 1
}
_1 = nil

local gap = {
    x = obj.track2,
    y = obj.track3,
    z = _2
}
_2 = nil

local w, h = obj.getpixel()
local res = {
    x = w,
    y = h,
    z = math.max(_3 or math.max(w, h), 0.0)
}
_3 = nil

local half_res = {
    x = res.x * 0.5,
    y = res.y * 0.5
}

-- Arithmetic Progression
-- Common Difference
local d = {
    x = res.x * gap.x * 0.01,
    y = res.y * gap.y * 0.01,
    z = res.z * gap.z * 0.01
}

-- First Term
local a = {
    x = -0.5 * d.x * count.x,
    y = -0.5 * d.y * count.y,
    z = -0.5 * d.z * count.z
}


obj.effect()
if (use_group_pivot) then
    local polys = {}
    local idx = 1
    for l = 0, count.z do
        local z = a.z + d.z * l
        for m = 0, count.x do
            local x = a.x + d.x * m
            local left = x - half_res.x
            local right = x + half_res.x

            for n = 0, count.y do
                local y = a.y + d.y * n
                local top = y - half_res.y
                local bottom = y + half_res.y
                polys[idx] = {
                    left,  top,    z,
                    right, top,    z,
                    right, bottom, z,
                    left,  bottom, z,
                    0,     0,
                    res.x, 0,
                    res.x, res.y,
                    0,     res.y
                }

                idx = idx + 1
            end
        end
    end

    obj.drawpoly(polys)
else
    for l = 0, count.z do
        local z = a.z + d.z * l
        for m = 0, count.x do
            local x = a.x + d.x * m
            for n = 0, count.y do
                local y = a.y + d.y * n
                obj.draw(x, y, z)
            end
        end
    end
end


@Repeat
--infomation:Repeat${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:Copies,1,1000,3,1
--track@_1:Offset,-1000,1000,0,1
--select@_2:Composite,Below=0,Above=1
--check0:Relative Position,0
--track1:X,-100000,100000,100,0.01
--track2:Y,-100000,100000,0,0.01
--track3:Z,-100000,100000,0,0.01
--track@_3:X Rotation,-3600,3600,0,0.01
--track@_4:Y Rotation,-3600,3600,0,0.01
--track@_5:Z Rotation,-3600,3600,0,0.01
--track@_6:Zoom,0,10000,100,0.001
--track@_7:Start Alpha,0,100,100,0.01
--track@_8:End Alpha,0,100,100,0.01
--value@_9:Z Size,math.max(obj.getpixel())
--value@_0:PI,{}

_0 = _0 or {}
local copies = math.max(math.floor(tonumber(_0.copies) or obj.track0), 1)
local offset = math.floor(tonumber(_0.offset) or _1) _1 = nil
local composite = math.floor(tonumber(_0.composite) or _2) _2 = nil
local rel_pos = obj.check0
if (type(_0.rel_pos) == "boolean") then
    rel_pos = _0.rel_pos
elseif (type(_0.rel_pos) == "number") then
    rel_pos = _0.rel_pos ~= 0
end
local x = tonumber(_0.x) or obj.track1
local y = tonumber(_0.y) or obj.track2
local z = tonumber(_0.z) or obj.track3
local rx = tonumber(_0.rx) or _3 _3 = nil
local ry = tonumber(_0.ry) or _4 _4 = nil
local rz = tonumber(_0.rz) or _5 _5 = nil
local scale = math.max(tonumber(_0.zoom) or _6, 0.0) * 0.01 _6 = nil
local a_st = math.max(tonumber(_0.st_alpha) or _7, 0.0) * 0.01 _7 = nil
local a_ed = math.max(tonumber(_0.ed_alpha) or _8, 0.0) * 0.01 _8 = nil
local z_size = tonumber(_9) _9 = nil
_0 = nil

local a_grad = a_ed - a_st
local last_idx = copies - 1
local st, ed, step = 0, last_idx, 1
if (composite == 0) then
    st, ed, step = ed, st, -1
end
if (rel_pos) then
    local w, h = obj.getpixel()
    x = w * x * 0.01
    y = h * y * 0.01
    z = (z_size or math.max(w ,h)) * z * 0.01
end

obj.effect()
for i = st, ed, step do
    local t = i / last_idx
    local alpha = a_st + a_grad * t
    i = i + offset
    obj.draw(x * i, y * i, z * i, math.pow(scale, i), alpha, rx * i, ry * i, rz * i)
end


@GradientMap
--infomation:GradientMap${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--file@_1:Map File
--track0:Map Layer,-256,256,0,1
--check@_9:Use Relative Layer,0
--check0:View Map,0
--track@_2:Map Hue,-3600,3600,0,0.01
--track1:Map Slice,0,100,50,0.01
--track2:Map Scale,0,1000,100,0.01
--track3:Map Shift,-500,500,0,0.01
--select@_3:Map Edges,Clamp=0,Repeat=1,Mirror=2
--check@_4:Invert Luma,0
--select@_5:Luma Mode=1,BT.601=0,BT.709=1,BT.2020=2
--select@_6:Color Space=1,Linear=0,sRGB=1
--select@_7:Blend Mode,Normal=0,Add=1,Subtract=2,Multiply=3,Screen=4,Overlay=5,Lighten=6,Darken=7,Luminosity=8,Chroma=9,Linear Burn=10,Linear Light=11,Difference=12
--track@_8:Mix,0,100,100,0.01
--[[pixelshader@gradient_map:
${SHADER_UTILS}
${SHADER_MAP_UTILS}
${SHADER_GRADIENT_MAP}
]]
--[[pixelshader@map_viewer:
${SHADER_UTILS}
${SHADER_MAP_UTILS}
${SHADER_MAP_VIEWER}
]]

local map_path = _1 _1 = nil
local map_layer = obj.track0
local use_rel_layer = _9 ~= 0 _9 = nil
local view_map = obj.check0
local map_hue = _2 _2 = nil
local map_slice = obj.track1 * 0.01
local map_scale = obj.track2 * 0.01
local map_shift = obj.track3 * 0.01
local map_edges = _3 _3 = nil
local inv_luma = _4 _4 = nil
local luma_mode = _5 _5 = nil
local col_space = _6 _6 = nil
local blend_mode = _7 _7 = nil
local mix = _8 * 0.01 _8= nil

local geo = {}
local map_w, map_h


local function err_handler(e)
    local hint = "Hint: Try increasing TemporaryImageCacheSize in system.conf."
    debug_print(string.format("%s. %s", e, hint))
end

local function copy_geo(dst, src)
    for k in ("ox, oy, oz, cx, cy, cz, rx, ry, rz, zoom, aspect, alpha"):gmatch("%a+") do
        dst[k] = src[k]
    end
end

local ok, e = pcall(function()
local layer = use_rel_layer and math.max(obj.layer + map_layer, 1) or math.max(map_layer, 0)
if (map_path == "" and (layer == 0 or layer == obj.layer)) then
    debug_print("The map not found.")
    return
end

copy_geo(geo, obj)
obj.copybuffer("tempbuffer", "object")
obj.copybuffer("cache:img", "object")

if (layer == 0 or layer == obj.layer) then
    obj.load("image", map_path)
else
    obj.load("layer", layer, true)
end

map_w, map_h = obj.getpixel()
if (map_w * map_h < 1) then
    debug_print("The map size is invalid.")
    obj.load("tempbuffer")
    copy_geo(obj, geo)
    return
end

obj.effect("色調補正", "色相", map_hue)

if (view_map) then
    obj.pixelshader("map_viewer", "object", "object", {
        map_w, map_h,
        map_slice,
        map_scale,
        map_shift,
        map_edges,
    })
    copy_geo(obj, geo)
    return
end

obj.pixelshader("gradient_map", "cache:img", {"cache:img", "object"}, {
    map_w, map_h,
    map_slice,
    map_scale,
    map_shift,
    map_edges,
    inv_luma,
    luma_mode,
    col_space
})

obj.copybuffer("object", "cache:img")
obj.clearbuffer("cache:img")

obj.setoption("drawtarget", "tempbuffer")
obj.setoption("blend", blend_mode)
obj.draw(0, 0, 0, 1, mix)
obj.setoption("blend", 0)

obj.load("tempbuffer")
obj.clearbuffer("tempbuffer")
copy_geo(obj, geo)
end)
if (not ok) then
    err_handler(e)
end


@Unpremultiply
--infomation:Unpremultiply${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:Gain,0,1000,100,0.01
--[[pixelshader@unpremult:
${SHADER_UNPREMULT}
]]

local gain = obj.track0 * 0.01


obj.pixelshader("unpremult", "object", "object", {
    gain
})
