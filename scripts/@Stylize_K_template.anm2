@Saturate
--infomation:Saturate${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:R Gain,0,1000,100,0.01
--track1:G Gain,0,1000,100,0.01
--track2:B Gain,0,1000,100,0.01
--track3:A Gain,0,1000,100,0.01
--select@_1:Color Space=1,Linear=0,sRGB=1
--track@_2:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@saturate:
${SHADER_UTILS}
${SHADER_SATURATE}
]]

_0 = _0 or {}
local r_gain = math.max(tonumber(_0.r_gain) or obj.track0, 0.0) * 0.01
local g_gain = math.max(tonumber(_0.g_gain) or obj.track1, 0.0) * 0.01
local b_gain = math.max(tonumber(_0.b_gain) or obj.track2, 0.0) * 0.01
local a_gain = math.max(tonumber(_0.a_gain) or obj.track3, 0.0) * 0.01
local col_space = tonumber(_0.col_space) or _1 _1 = nil
local mix = math.max(math.min(tonumber(_0.mix) or _2, 100.0), 0.0) * 0.01 _2 = nil
_0 = nil

obj.pixelshader("saturate", "object", "object", {
    r_gain, g_gain, b_gain, a_gain,
    col_space,
    mix
})


@Mosaic
--infomation:Mosaic${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:X Blocks,1,16384,32,1
--track1:Y Blocks,1,16384,32,1
--check0:Sharp Colors,0
--value@_0:PI,{}
--[[computeshader@mosaic_ave:
${SHADER_MOSAIC_AVE}
]]
--[[pixelshader@mosaic_draw:
${SHADER_MOSAIC_DRAW}
]]
--[[pixelshader@mosaic_point:
${SHADER_MOSAIC_POINT}
]]

_0 = _0 or {}
local bx = math.floor(tonumber(_0.bx) or obj.track0)
local by = math.floor(tonumber(_0.by) or obj.track1)
local sharp_col = obj.check0
if (type(_0.sharp_col) == "boolean") then
    sharp_col = _0.sharp_col
elseif (type(_0.sharp_col) == "number") then
    sharp_col = _0.sharp_col ~= 0
end
_0 = nil

local function err_handler(e)
    local hint = "Hint: Try increasing TemporaryImageCacheSize in system.conf."
    debug_print(string.format("%s. %s", e, hint))
end

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

local ok, e = pcall(function()
local w, h = obj.getpixel()
bx = clamp(bx, 1, w)
by = clamp(by, 1, h)

if (sharp_col) then
    obj.pixelshader("mosaic_point", "object", "object", {
        bx, by,
        w, h
    })
else
    local n = 256
    obj.setoption("drawtarget", "tempbuffer", bx, by)
    obj.computeshader("mosaic_ave", "tempbuffer", "object", {
        bx, by,
        w, h,
        n,
        bx * by
    },
    n, 1, 1)

    obj.pixelshader("mosaic_draw", "object", "tempbuffer", {
        bx, by,
        w, h
    })

    obj.clearbuffer("tempbuffer")
end
end)
if (not ok) then
    err_handler(e)
end


@Threshold
--infomation:Threshold${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:Threshold,0,255,128
--select@_1:Channel=1,Luminance (BT.601)=0,Luminance (BT.709)=1,Luminance (BT.2020)=2,Value=3,Saturation=4,Hue=5,Alpha=6
--check0:Invert,0
--color@_2:Light Color,0xffffff
--track2:Light Alpha,0,100,100,0.01
--color@_3:Dark Color,0x000000
--track3:Dark Alpha,0,100,100,0.01
--select@_4:Color Space=1,Linear=0,sRGB=1
--track1:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@thresholding:
${SHADER_UTILS}
${SHADER_THRESHOLD}
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local threshold = clamp(tonumber(_0.threshold) or obj.track0, 0.0, 255.0) / 255.0
local channel = tonumber(_0.channel) or _1 _1 = nil
local inv = obj.check0 and 1 or 0
if (type(_0.inv) == "boolean") then
    inv = _0.inv and 1 or 0
elseif (type(_0.inv) == "boolean") then
    inv = _0.inv ~= 0 and 1 or 0
end
local light_col = clamp(tonumber(_0.light_col) or _2, 0x000000, 0xffffff) _2 = nil
local light_a = clamp(tonumber(_0.light_a) or obj.track2, 0.0, 100.0) * 0.01
local dark_col = clamp(tonumber(_0.dark_col) or _3, 0x000000, 0xffffff) _3 = nil
local dark_a = clamp(tonumber(_0.dark_a) or obj.track3, 0.0, 100.0) * 0.01
local col_space = tonumber(_0.col_space) or _4 _4 = nil
local mix = clamp(tonumber(_0.mix) or obj.track1, 0.0, 100.0) * 0.01
_0 = nil

obj.pixelshader("thresholding", "object", "object", {
    threshold,
    channel,
    inv,
    light_col,
    light_a,
    dark_col,
    dark_a,
    col_space,
    mix
})


@Threshold(RGBA)
--infomation:Threshold(RGBA)${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:R Threshold,0,255,128
--track1:G Threshold,0,255,128
--track2:B Threshold,0,255,128
--track3:A Threshold,0,255,128
--check@_1:Invert R,0
--check@_2:Invert G,0
--check@_3:Invert B,0
--check@_4:Invert A,0
--check0:Disable A Threshold,0
--select@_5:Color Space=1,Linear=0,sRGB=1
--track@_6:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@thresholding_rgba:
${SHADER_UTILS}
${SHADER_THRESHOLD_RGBA}
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local r_threshold = clamp(tonumber(_0.r_threshold) or obj.track0, 0.0, 255.0) / 255.0
local g_threshold = clamp(tonumber(_0.g_threshold) or obj.track1, 0.0, 255.0) / 255.0
local b_threshold = clamp(tonumber(_0.b_threshold) or obj.track2, 0.0, 255.0) / 255.0
local a_threshold = clamp(tonumber(_0.a_threshold) or obj.track3, 0.0, 255.0) / 255.0
local inv_r = _1 _1 = nil
if (type(_0.inv_r) == "boolean") then
    inv_r = _0.inv_r and 1 or 0
elseif (type(_0.inv_r) == "number") then
    inv_r = _0.inv_r ~= 0 and 1 or 0
end
local inv_g = _2 _2 = nil
if (type(_0.inv_g) == "boolean") then
    inv_g = _0.inv_g and 1 or 0
elseif (type(_0.inv_g) == "number") then
    inv_g = _0.inv_g ~= 0 and 1 or 0
end
local inv_b = _3 _3 = nil
if (type(_0.inv_b) == "boolean") then
    inv_b = _0.inv_b and 1 or 0
elseif (type(_0.inv_b) == "number") then
    inv_b = _0.inv_b ~= 0 and 1 or 0
end
local inv_a = _4 _4 = nil
if (type(_0.inv_a) == "boolean") then
    inv_a = _0.inv_a and 1 or 0
elseif (type(_0.inv_a) == "number") then
    inv_a = _0.inv_a ~= 0 and 1 or 0
end
local disable_a = obj.check0 and 1 or 0
if (type(_0.disable_a) == "boolean") then
    disable_a = _0.disable_a and 1 or 0
elseif (type(_0.disable_a) == "number") then
    disable_a = disable_a ~= 0 and 1 or 0
end
local col_space = tonumber(_0.col_space) or _5 _5 = nil
local mix = clamp(tonumber(_0.mix) or _6, 0.0, 100.0) * 0.01 _6 = nil
_0 = nil

obj.pixelshader("thresholding_rgba", "object", "object", {
    r_threshold, g_threshold, b_threshold, a_threshold,
    inv_r, inv_g, inv_b, inv_a,
    disable_a,
    col_space,
    mix
})


@Posterize
--infomation:Posterize${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:Level,1,256,8,1
--select@_1:Channel,RGB=0,RGBA=1,Value=2,Value A=3
--track@_2:Size,1,2000,1,1
--check@_5:Sharp Colors,0
--select@_3:Color Space=1,Linear=0,sRGB=1
--track@_4:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@posterize:
${SHADER_UTILS}
${SHADER_POSTERIZE}
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local level = clamp(math.floor(tonumber(_0.level) or obj.track0), 1, 256)
local channel = tonumber(_0.channel) or _1 _1 = nil
local size = math.max(math.floor(tonumber(_0.size) or _2), 1) _2 = nil
local sharp_col = _5 _5 = nil
if (type(_0.sharp_col) == "boolean") then
    sharp_col = _0.sharp_col and 1 or 0
elseif (type(_0.sharp_col) == "number") then
    sharp_col = _0.sharp_col ~= 0 and 1 or 0
end
local col_space = tonumber(_0.col_space) or _3 _3 = nil
local mix = clamp(tonumber(_0.mix) or _4, 0.0, 100.0) * 0.01 _4 = nil
_0 = nil

if (size > 1) then
    local w, h = obj.getpixel()
    local mosaic_params = string.format("bx = %d, by = %d, sharp_col = %d", w / size, h / size, sharp_col)
    obj.effect("Mosaic@Stylize_K", "PI", mosaic_params)
end

obj.pixelshader("posterize", "object", "object", {
    level,
    channel,
    col_space,
    mix
})


@Posterize(RGBA)
--infomation:Posterize(RGBA)${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:R Level,1,256,8,1
--track1:G Level,1,256,8,1
--track2:B Level,1,256,8,1
--track3:A Level,1,256,8,1
--check0:Disable A Level,0
--track@_1:Size,1,2000,1,1
--check@_2:Sharp Colors,0
--select@_3:Color Space=1,Linear=0,sRGB=1
--track@_4:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@posterize_rgba:
${SHADER_UTILS}
${SHADER_POSTERIZE_RGBA}
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local r_level = clamp(math.floor(tonumber(_0.r_level) or obj.track0), 1, 256)
local g_level = clamp(math.floor(tonumber(_0.g_level) or obj.track1), 1, 256)
local b_level = clamp(math.floor(tonumber(_0.b_level) or obj.track2), 1, 256)
local a_level = clamp(math.floor(tonumber(_0.a_level) or obj.track3), 1, 256)
local disable_a = obj.check0 and 1 or 0
if (type(_0.disable_a) == "boolean") then
    disable_a = _0.disable_a and 1 or 0
elseif (type(_0.disable_a) == "number") then
    disable_a = disable_a ~= 0 and 1 or 0
end
local size = math.max(math.floor(tonumber(_0.size) or _1), 1) _1 = nil
local sharp_col = _2 _2 = nil
if (type(_0.sharp_col) == "boolean") then
    sharp_col = _0.sharp_col and 1 or 0
elseif (type(_0.sharp_col) == "number") then
    sharp_col = _0.sharp_col ~= 0 and 1 or 0
end
local col_space = tonumber(_0.col_space) or _3 _3 = nil
local mix = clamp(tonumber(_0.mix) or _4, 0.0, 100.0) * 0.01 _4 = nil
_0 = nil

if (size > 1) then
    local w, h = obj.getpixel()
    local mosaic_params = string.format("bx = %d, by = %d, sharp_col = %d", w / size, h / size, sharp_col)
    obj.effect("Mosaic@Stylize_K", "PI", mosaic_params)
end

obj.pixelshader("posterize_rgba", "object", "object", {
    r_level, g_level, b_level, a_level,
    disable_a,
    col_space,
    mix
})


@ASCII
--infomation:ASCII${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--value@_1:Glyphs,"@#%*+=-:. "
--font@_2:Font,Yu Gothic UI
--track@_3:Padding,-100,100,0,1
--track0:X Blocks,1,16384,80,1
--track1:Y Blocks,1,16384,45,1
--check0:Sharp Colors,0
--track@_4:Luma Gain,0,1000,100,0.01
--track2:Min Luma,0,100,0,0.01
--track3:Max Luma,0,100,100,0.01
--select@_5:Luma Mode=1,BT.601=0,BT.709=1,BT.2020=2
--check@_6:Invert Luma,1
--select@_7:Glyph Type=0,Solid=0,Original=1,Mosaic=2
--color@_8:Glyph Color,0xffffff
--select@_9:Canvas Type,Transparent=0,Solid=1,Original=2,Mosaic=3
--color@_10:Canvas Color,0x000000
--select@_11:Color Space=1,Linear=0,sRGB=1
--select@_12:Alpha,None=0,Premultiplied=1
--select@_13:Blend Mode,Normal=0,Add=1,Subtract=2,Multiply=3,Screen=4,Overlay=5,Lighten=6,Darken=7,Luminosity=8,Chroma=9,Linear Burn=10,Linear Light=11,Difference=12
--track@_14:Mix,0,100,100,0.01
--check@_15:Shuffle Glyphs,0
--value@_16:Excluded Glyphs,""
--track@_17:Interval,0,100,0,1
--track@_18:Seed,-1000,1000,-1,1
--value@_0:PI,{}
--[[pixelshader@ascii:
${SHADER_UTILS}
${SHADER_ASCII}
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local glyphs_str = _0.glyphs and tostring(_0.glyphs) or _1 _1 = nil
local font = _0.font and tostring(_0.font) or _2 _2 = nil
local padding = math.floor(tonumber(_0.padding) or _3) _3 = nil
local bx = clamp(math.floor(tonumber(_0.bx) or obj.track0), 1, 16384)
local by = clamp(math.floor(tonumber(_0.by) or obj.track1), 1, 16384)
local sharp_col = obj.check0 and 1 or 0
if (type(_0.sharp_col) == "boolean") then
    sharp_col = _0.sharp_col and 1 or 0
elseif (type(_0.sharp_col) == "number") then
    sharp_col = _0.sharp_col ~= 0 and 1 or 0
end
local luma_gain = math.max(tonumber(_0.luma_gain) or _4, 0.0) * 0.01 _4 = nil
local min_luma = clamp(tonumber(_0.min_luma) or obj.track2, 0.0, 100.0) * 0.01
local max_luma = clamp(tonumber(_0.max_luma) or obj.track3, 0.0, 100.0) * 0.01
local luma_mode = tonumber(_0.luma_mode) or _5 _5 = nil
local inv_luma = _6 _6 = nil
if (type(_0.inv_luma) == "boolean") then
    inv_luma = _0.inv_luma and 1 or 0
elseif (type(_0.inv_luma) == "number") then
    inv_luma = _0.inv_luma ~= 0 and 1 or 0
end
local glyph_type = tonumber(_0.glyph_type) or _7 _7 = nil
local glyph_col = clamp(tonumber(_0.glyph_col) or _8, 0x000000, 0xffffff) _8 = nil
local canvas_type = tonumber(_0.canvas_type) or _9 _9 = nil
local canvas_col = clamp(tonumber(_0.canvas_col) or _10, 0x000000, 0xffffff) _10 = nil
local col_space = tonumber(_0.col_space) or _11 _11 = nil
local alpha = tonumber(_0.alpha) or _12 _12 = nil
local blend_mode = tonumber(_0.blend_mode) or _13 _13= nil
local mix = clamp(tonumber(_0.mix) or _14, 0.0, 100.0) * 0.01 _14 = nil
local shuf_glyphs = _15 ~= 0 _15 = nil
if (type(_0.shuf_glyphs) == "boolean") then
    shuf_glyphs = _0.shuf_glyphs
elseif (type(_0.shuf_glyphs) == "number") then
    shuf_glyphs = _0.inv_luma ~= 0
end
local exclude_str = _0.excluded_glyphs and tonumber(_0.excluded_glyphs) or _16 _16 = nil
local interval = math.max(tonumber(_0.interval) or _17, 0) _17 = nil
local seed = tonumber(_0.seed) or _18 _18 = nil
_0 = nil

if (glyphs_str == "") then
    debug_print("The text cannot be empty.")
    return
end

local function err_handler(e)
    local hint = "Hint: Try increasing TemporaryImageCacheSize in system.conf."
    debug_print(string.format("%s. %s", e, hint))
end

local function copy_geo(dst, src)
    for k in ("ox, oy, oz, cx, cy, cz, rx, ry, rz, zoom, aspect, alpha"):gmatch("%a+") do
        dst[k] = src[k]
    end
end

local function split_utf8(str)
    local t = {}
    local i = 1
    while i <= #str do
        local byte = string.byte(str, i)
        local len

        if (byte < 0x80) then
            len = 1
        elseif (byte < 0xE0) then
            len = 2
        elseif (byte < 0xF0) then
            len = 3
        else
            len = 4
        end

        table.insert(t, string.sub(str, i, i + len - 1))
        i = i + len
    end
    return t
end

local function shuffle(t, exclude)
    local set = {}
    for _, v in ipairs(exclude or {}) do
        set[v] = true
    end

    local indices = {}
    local len = 0
    for i = 1, #t do
        if not set[t[i]] then
            len = len + 1
            indices[len] = i
        end
    end

    local f = interval > 0 and math.floor(obj.frame / interval) or 0
    for i = len, 2, -1 do
        local j = obj.rand(1, i, seed, f)
        local m, n = indices[i], indices[j]
        t[m], t[n] = t[n], t[m]
    end
end

local ok, e = pcall(function()
    local geo = {}
    local blend = glyph_type == 1 and "mask" or "copy"
    local col_list = {0xff0000, 0x00ff00, 0x0000ff}
    local w, h = obj.getpixel()
    local max_w, max_h = obj.getinfo("image_max")
    local bw, bh = math.floor(w / bx), math.floor(h / by)
    local mosaic_params = string.format("bx = %d, by = %d, sharp_col = %d", bx, by, sharp_col)
    local size = math.max(math.min(bw, bh) - padding * 2, 0)
    local glyphs = split_utf8(glyphs_str)
    local exclude = split_utf8(exclude_str)
    local len = #glyphs
    local map_w, map_h = bw * math.ceil(len / 3.0), bh
    if (map_w > max_w or map_h > max_h) then
        debug_print("The font size is too large or the text is too long.")
        return
    end

    copy_geo(geo, obj)
    obj.copybuffer("cache:img", "object")
    obj.effect("Mosaic@Stylize_K", "PI", mosaic_params)
    obj.copybuffer("cache:mosaic", "object")

    obj.setoption("drawtarget", "tempbuffer", map_w, map_h)
    obj.setoption("blend", 1)
    if (shuf_glyphs) then
        shuffle(glyphs, exclude)
    end

    local a = -0.5 * (map_w - bw)
    for i = 1, len do
        local idx = i - 1
        obj.setfont(font, size, 0, col_list[(idx % 3) + 1])
        obj.load("text", glyphs[i])
        obj.draw(a + bw * (math.floor(idx / 3)))
    end

    obj.copybuffer("object", "cache:img")
    obj.pixelshader("ascii", "object", {
        "cache:mosaic",
        "tempbuffer"
    }, {
        bx, by,
        w, h,
        map_w, map_h,
        min_luma, max_luma,
        len,
        luma_gain,
        luma_mode,
        inv_luma,
        glyph_type,
        glyph_col,
        col_space,
        alpha
    }, blend)

    if (canvas_type == 1) then
        obj.setoption("drawtarget", "tempbuffer", w, h)
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")

        obj.copybuffer("cache:ascii", "object")
        obj.load("figure", "四角形", canvas_col, 1)
        local half_w, half_h = w * 0.5, h * 0.5
        obj.drawpoly(
            -half_w, -half_h, 0,
            half_w,  -half_h, 0,
            half_w,  half_h,  0,
            -half_w, half_h,  0
        )
        obj.copybuffer("object", "cache:ascii")
    elseif (canvas_type == 2) then
        obj.copybuffer("tempbuffer", "cache:img")
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")
    elseif (canvas_type == 3) then
        obj.copybuffer("tempbuffer", "cache:mosaic")
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")
    else
        obj.setoption("drawtarget", "tempbuffer", w, h)
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")
    end

    obj.setoption("blend", blend_mode)
    obj.draw(0, 0, 0, 1, mix)
    obj.setoption("blend", 0)

    obj.load("tempbuffer")
    obj.clearbuffer("tempbuffer")
    copy_geo(obj, geo)
end)
if (not ok) then
    err_handler(e)
end


@MotionTile
--infomation:MotionTile${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:X Center,-4000,4000,0,0.01
--track1:Y Center,-4000,4000,0,0.01
--track2:Output W,0,1000,100,0.01
--track3:Output H,0,1000,100,0.01
--track@_1:Tile W,0,1000,100,0.01
--track@_2:Tile H,0,1000,100,0.01
--check@_3:Mirror Horizontal Edge,0
--check@_4:Mirror Vertical Edge,0
--track@_5:Phase,-3600,3600,0,0.01
--check0:Horizontal Shift,0
--value@_0:PI,{}
--[[pixelshader@motion_tile:
${SHADER_MOTION_TILE}
]]

obj.setanchor("track", 0, "line")

local w, h = obj.getpixel()

_0 = _0 or {}
local cx = (tonumber(_0.cx) or obj.track0) / w
local cy = (tonumber(_0.cy) or obj.track1) / h
local out_w = math.max(tonumber(_0.out_w) or obj.track2, 0.0) * 0.01
local out_h = math.max(tonumber(_0.out_h) or obj.track3, 0.0) * 0.01
local tile_w = math.max(tonumber(_0.tile_w) or _1, 0.0) * 0.01 _1 = nil
local tile_h = math.max(tonumber(_0.tile_h) or _2, 0.0) * 0.01 _2 = nil
local mirror_h = _3 _3 = nil
if (type(_0.mirror_h) == "boolean") then
    mirror_h = _0.mirror_h and 1 or 0
elseif (type(_0.mirror_h) == "number") then
    mirror_h = _0.mirror_h ~= 0 and 1 or 0
end
local mirror_v = _4 _4 = nil
if (type(_0.mirror_v) == "boolean") then
    mirror_v = _0.mirror_v and 1 or 0
elseif (type(_0.mirror_v) == "number") then
    mirror_v = _0.mirror_v ~= 0 and 1 or 0
end
local phase = (tonumber(_0.phase) or _5) / 360.0 _5 = nil
local h_shift = obj.check0 and 1 or 0
if (type(_0.h_shift) == "boolean") then
    h_shift = _0.h_shift and 1 or 0
elseif (type(_0.h_shift) == "number") then
    h_shift = _0.h_shift ~= 0 and 1 or 0
end
_0 = nil

local geo = {}
local max_w, max_h = obj.getinfo("image_max")
local out_res_w = math.min(math.floor(w * out_w), max_w)
local out_res_h = math.min(math.floor(h * out_h), max_h)


local function err_handler(e)
    local hint = "Hint: Try increasing TemporaryImageCacheSize in system.conf."
    debug_print(string.format("%s. %s", e, hint))
end

local function copy_geo(dst, src)
    for k in ("ox, oy, oz, cx, cy, cz, rx, ry, rz, zoom, aspect, alpha"):gmatch("%a+") do
        dst[k] = src[k]
    end
end


if (out_res_w * out_res_h < 1) then
    obj.effect("リサイズ", "拡大率", 0)
    return
end

out_w = out_res_w / w
out_h = out_res_h / h

local ok, e = pcall(function()
copy_geo(geo, obj)
obj.setoption("drawtarget", "tempbuffer", out_res_w, out_res_h)

obj.pixelshader("motion_tile", "tempbuffer", "object", {
    w, h,
    cx, cy,
    out_w, out_h,
    tile_w, tile_h,
    mirror_h, mirror_v,
    phase,
    h_shift
})

obj.load("tempbuffer")
obj.clearbuffer("tempbuffer")
copy_geo(obj, geo)
end)
if (not ok) then
    err_handler(e)
end


@Tile
--infomation:Tile${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:X Count,1,100,3,1
--track1:Y Count,1,100,3,1
--track@_1:Z Count,1,100,1,1
--track2:X Gap,0,1000,100,0.01
--track3:Y Gap,0,1000,100,0.01
--track@_2:Z Gap,0,1000,100,0.01
--track@_4:X Offset,-1000,1000,0,0.01
--track@_5:Y Offset,-1000,1000,0,0.01
--check@_6:Mirror Copies,1
--check0:Use Group Pivot,1
--value@_3:Z Size,math.max(obj.getpixel())
--value@_0:PI,{}

_0 = _0 or {}
local mirror_copies = _6 ~= 0 _6 = nil
if (type(_0.mirror_copies) == "boolean") then
    mirror_copies = _0.mirror_copies
elseif (type(_0.mirror_copies) == "number") then
    mirror_copies = _0.mirror_copies ~= 0
end
local use_group_pivot = obj.check0
if (type(_0.use_group_pivot) == "boolean") then
    use_group_pivot = _0.use_group_pivot
elseif (type(_0.use_group_pivot) == "number") then
    use_group_pivot = _0.use_group_pivot ~= 0
end

local count = {
    x = math.max(math.floor(tonumber(_0.x_count) or obj.track0), 1) - 1,
    y = math.max(math.floor(tonumber(_0.y_count) or obj.track1), 1) - 1,
    z = math.max(math.floor(tonumber(_0.z_count) or _1), 1) - 1
}
_1 = nil

local gap = {
    x = math.max(tonumber(_0.x_gap) or obj.track2, 0.0) * 0.01,
    y = math.max(tonumber(_0.y_gap) or obj.track3, 0.0) * 0.01,
    z = math.max(tonumber(_0.z_gap) or _2, 0.0) * 0.01
}
_2 = nil

local offset = {
    x = (tonumber(_0.x_offset) or _4) * 0.01,
    y = (tonumber(_0.y_offset) or _5) * 0.01
}
_4 = nil
_5 = nil

local w, h = obj.getpixel()
local res = {
    x = w,
    y = h,
    z = math.max(tonumber(_3) or math.max(w, h), 0.0)
}
_3 = nil
_0 = nil

local half_res = {
    x = res.x * 0.5,
    y = res.y * 0.5
}

-- Arithmetic Progression
-- Offset
local o = {
    x = offset.x * res.x / count.y,
    y = offset.y * res.y / count.x
}

-- Common Difference
local d = {
    x = res.x * gap.x,
    y = res.y * gap.y,
    z = res.z * gap.z
}

-- First Term
local a = {x = 0.0, y = 0.0, z = 0.0}
if (mirror_copies) then
    a = {
        x = -0.5 * (d.x * count.x + offset.x * res.x),
        y = -0.5 * (d.y * count.y + offset.y * res.y),
        z = -0.5 * d.z * count.z
    }
end

obj.effect()
if (use_group_pivot) then
    local polys = {}
    local idx = 1
    for l = 0, count.z do
        local z = a.z + d.z * l
        for m = 0, count.x do
            local x = a.x + d.x * m
            for n = 0, count.y do
                local y = a.y + d.y * n

                local ox = x + o.x * n
                local oy = y + o.y * m

                local left = ox - half_res.x
                local right = ox + half_res.x
                local top = oy - half_res.y
                local bottom = oy + half_res.y
                polys[idx] = {
                    left,  top,    z,
                    right, top,    z,
                    right, bottom, z,
                    left,  bottom, z,
                    0,     0,
                    res.x, 0,
                    res.x, res.y,
                    0,     res.y
                }

                idx = idx + 1
            end
        end
    end

    obj.drawpoly(polys)
else
    for l = 0, count.z do
        local z = a.z + d.z * l
        for m = 0, count.x do
            local x = a.x + d.x * m
            for n = 0, count.y do
                local y = a.y + d.y * n

                local ox = x + o.x * n
                local oy = y + o.y * m

                obj.draw(ox, oy, z)
            end
        end
    end
end


@Repeat
--infomation:Repeat${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:Count,1,1000,3,1
--track@_1:Offset,-1000,1000,0,1
--select@_2:Composite,Below=0,Above=1
--track1:X,-100000,100000,100,0.01
--track2:Y,-100000,100000,0,0.01
--track3:Z,-100000,100000,0,0.01
--track@_3:X Rotation,-3600,3600,0,0.01
--track@_4:Y Rotation,-3600,3600,0,0.01
--track@_5:Z Rotation,-3600,3600,0,0.01
--track@_6:Zoom,0,10000,100,0.001
--track@_7:Start Alpha,0,100,100,0.01
--track@_8:End Alpha,0,100,100,0.01
--value@_0:PI,{}

_0 = _0 or {}
local count = math.max(math.floor(tonumber(_0.count) or obj.track0), 1)
local offset = math.floor(tonumber(_0.offset) or _1) _1 = nil
local composite = tonumber(_0.composite) or _2 _2 = nil
local x = tonumber(_0.x) or obj.track1
local y = tonumber(_0.y) or obj.track2
local z = tonumber(_0.z) or obj.track3
local rx = tonumber(_0.rx) or _3 _3 = nil
local ry = tonumber(_0.ry) or _4 _4 = nil
local rz = tonumber(_0.rz) or _5 _5 = nil
local scale = math.max(tonumber(_0.zoom) or _6, 0.0) * 0.01 _6 = nil
local a_st = math.max(tonumber(_0.st_alpha) or _7, 0.0) * 0.01 _7 = nil
local a_ed = math.max(tonumber(_0.ed_alpha) or _8, 0.0) * 0.01 _8 = nil
_0 = nil

local a_grad = a_ed - a_st
local last_idx = count - 1
local st, ed, step = 0, last_idx, 1
if (composite == 0) then
    st, ed, step = ed, st, -1
end

obj.effect()
for i = st, ed, step do
    local t = i / last_idx
    local alpha = a_st + a_grad * t
    i = i + offset
    obj.draw(x * i, y * i, z * i, math.pow(scale, i), alpha, rx * i, ry * i, rz * i)
end


@GradientMap
--infomation:GradientMap${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--file@_1:Map File
--track0:Map Layer,-256,256,0,1
--check@_9:Use Relative Layer,0
--check0:View Map,0
--track@_2:Map Hue,-3600,3600,0,0.01
--track1:Map Slice,0,100,50,0.01
--track2:Map Scale,0,1000,100,0.01
--track3:Map Shift,-1000,1000,0,0.01
--select@_3:Map Edges,Clamp=0,Repeat=1,Mirror=2
--check@_4:Invert Luma,0
--select@_5:Luma Mode=1,BT.601=0,BT.709=1,BT.2020=2
--select@_6:Color Space=1,Linear=0,sRGB=1
--select@_7:Blend Mode,Normal=0,Add=1,Subtract=2,Multiply=3,Screen=4,Overlay=5,Lighten=6,Darken=7,Luminosity=8,Chroma=9,Linear Burn=10,Linear Light=11,Difference=12
--track@_8:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@gradient_map:
${SHADER_UTILS}
${SHADER_MAP_UTILS}
${SHADER_GRADIENT_MAP}
]]
--[[pixelshader@map_viewer:
${SHADER_UTILS}
${SHADER_MAP_UTILS}
${SHADER_MAP_VIEWER}
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local map_path = _0.map_path and tostring(_0.map_path) or _1 _1 = nil
local map_layer = math.floor(tonumber(_0.map_layer) or obj.track0)
local use_rel_layer = _9 ~= 0 _9 = nil
if (type(_0.use_rel_layer) == "boolean") then
    use_rel_layer = _0.use_rel_layer
elseif (type(_0.use_rel_layer) == "number") then
    use_rel_layer = _0.use_rel_layer ~= 0
end
local view_map = obj.check0
if (type(_0.view_map) == "boolean") then
    view_map = _0.view_map
elseif (type(_0.view_map) == "number") then
    use_rel_layer = _0.use_rel_layer ~= 0
end
local map_hue = tonumber(_0.map_hue) or _2 _2 = nil
local map_slice = clamp(tonumber(_0.map_slice) or obj.track1, 0.0, 100.0) * 0.01
local map_scale = math.max(tonumber(_0.map_scale) or obj.track2, 0.0) * 0.01
local map_shift = tonumber(_0.map_shift) or obj.track3 * 0.01
local map_edges = tonumber(_0.map_edges) or _3 _3 = nil
local inv_luma = _4 _4 = nil
if (type(_0.inv_luma) == "boolean") then
    inv_luma = _0.inv_luma and 1 or 0
elseif (type(_0.inv_luma) == "number") then
    inv_luma = _0.inv_luma ~= 0 and 1 or 0
end
local luma_mode = tonumber(_0.luma_mode) or _5 _5 = nil
local col_space = tonumber(_0.col_space) or _6 _6 = nil
local blend_mode = tonumber(_0.blend_mode) or _7 _7 = nil
local mix = clamp(tonumber(_0.mix) or _8, 0.0, 100.0) * 0.01 _8= nil
_0 = nil

local function err_handler(e)
    local hint = "Hint: Try increasing TemporaryImageCacheSize in system.conf."
    debug_print(string.format("%s. %s", e, hint))
end

local function copy_geo(dst, src)
    for k in ("ox, oy, oz, cx, cy, cz, rx, ry, rz, zoom, aspect, alpha"):gmatch("%a+") do
        dst[k] = src[k]
    end
end

local ok, e = pcall(function()
local geo = {}
local map_w, map_h
local layer = use_rel_layer and math.max(obj.layer + map_layer, 1) or math.max(map_layer, 0)
if (map_path == "" and (layer == 0 or layer == obj.layer)) then
    debug_print("The map not found.")
    return
end

copy_geo(geo, obj)
obj.copybuffer("tempbuffer", "object")
obj.copybuffer("cache:img", "object")

if (layer == 0 or layer == obj.layer) then
    obj.load("image", map_path)
else
    obj.load("layer", layer, true)
end

map_w, map_h = obj.getpixel()
if (map_w * map_h < 1) then
    debug_print("The map size is invalid.")
    obj.load("tempbuffer")
    copy_geo(obj, geo)
    return
end

obj.effect("色調補正", "色相", map_hue)

if (view_map) then
    obj.pixelshader("map_viewer", "object", "object", {
        map_w, map_h,
        map_slice,
        map_scale,
        map_shift,
        map_edges,
    })
    copy_geo(obj, geo)
    return
end

obj.pixelshader("gradient_map", "cache:img", {"cache:img", "object"}, {
    map_w, map_h,
    map_slice,
    map_scale,
    map_shift,
    map_edges,
    inv_luma,
    luma_mode,
    col_space
})

obj.copybuffer("object", "cache:img")
obj.clearbuffer("cache:img")

obj.setoption("drawtarget", "tempbuffer")
obj.setoption("blend", blend_mode)
obj.draw(0, 0, 0, 1, mix)
obj.setoption("blend", 0)

obj.load("tempbuffer")
obj.clearbuffer("tempbuffer")
copy_geo(obj, geo)
end)
if (not ok) then
    err_handler(e)
end


@Unpremultiply
--infomation:Unpremultiply${SCRIPT_NAME} ${VERSION}
--label:${LABEL}
--track0:Gain,0,1000,100,0.01
--value@_0:PI,{}
--[[pixelshader@unpremult:
${SHADER_UNPREMULT}
]]

_0 = _0 or {}
local gain = math.max(tonumber(_0.gain) or obj.track0, 0.0) * 0.01
_0 = nil

obj.pixelshader("unpremult", "object", "object", {
    gain
})
