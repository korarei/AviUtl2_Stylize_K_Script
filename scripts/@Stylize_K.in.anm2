@Saturate
--information:Saturate${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--track0:R Gain,0,1000,100,0.01
--track1:G Gain,0,1000,100,0.01
--track2:B Gain,0,1000,100,0.01
--track3:A Gain,0,1000,100,0.01
--select@_1:Color Space=1,Linear=0,sRGB=1
--track@_2:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@saturate:
--#include "shaders/utils.hlsl"
--#include "shaders/saturate.hlsl"
]]

_0 = _0 or {}
local r_gain = math.max(tonumber(_0.r_gain) or obj.track0, 0.0) * 0.01
local g_gain = math.max(tonumber(_0.g_gain) or obj.track1, 0.0) * 0.01
local b_gain = math.max(tonumber(_0.b_gain) or obj.track2, 0.0) * 0.01
local a_gain = math.max(tonumber(_0.a_gain) or obj.track3, 0.0) * 0.01
local col_space = tonumber(_0.col_space) or _1 _1 = nil
local mix = math.max(math.min(tonumber(_0.mix) or _2, 100.0), 0.0) * 0.01 _2 = nil
_0 = nil

obj.pixelshader("saturate", "object", "object", {
    r_gain, g_gain, b_gain, a_gain,
    col_space,
    mix
})


@Mosaic
--information:Mosaic${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--track0:X Blocks,1,16384,32,1
--track1:Y Blocks,1,16384,32,1
--check0:Sharp Colors,0
--value@_0:PI,{}
--[[computeshader@mosaic_ave:
--#include "shaders/mosaic_ave.hlsl"
]]
--[[pixelshader@mosaic_draw:
--#include "shaders/mosaic_draw.hlsl"
]]
--[[pixelshader@mosaic_point:
--#include "shaders/mosaic_point.hlsl"
]]

_0 = _0 or {}
local bx = math.floor(tonumber(_0.bx) or obj.track0)
local by = math.floor(tonumber(_0.by) or obj.track1)
local sharp_col = obj.check0
if (type(_0.sharp_col) == "boolean") then
    sharp_col = _0.sharp_col
elseif (type(_0.sharp_col) == "number") then
    sharp_col = _0.sharp_col ~= 0
end
_0 = nil

local function err_handler(e)
    local hint = "Hint: Try increasing TemporaryImageCacheSize in system.conf."
    debug_print(string.format("%s. %s", e, hint))
end

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

local ok, e = pcall(function()
local w, h = obj.getpixel()
bx = clamp(bx, 1, w)
by = clamp(by, 1, h)

if (sharp_col) then
    obj.pixelshader("mosaic_point", "object", "object", {
        bx, by,
        w, h
    })
else
    local n = 256
    obj.setoption("drawtarget", "tempbuffer", bx, by)
    obj.computeshader("mosaic_ave", "tempbuffer", "object", {
        bx, by,
        w, h,
        n,
        bx * by
    },
    n, 1, 1)

    obj.pixelshader("mosaic_draw", "object", "tempbuffer", {
        bx, by,
        w, h
    })

    obj.clearbuffer("tempbuffer")
end
end)
if (not ok) then
    err_handler(e)
end


@Threshold
--information:Threshold${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--track0:Threshold,0,255,128
--select@_1:Channel=1,Luminance (BT.601)=0,Luminance (BT.709)=1,Luminance (BT.2020)=2,Value=3,Saturation=4,Hue=5,Alpha=6
--check0:Invert,0
--color@_2:Light Color,0xffffff
--track2:Light Alpha,0,100,100,0.01
--color@_3:Dark Color,0x000000
--track3:Dark Alpha,0,100,100,0.01
--select@_4:Color Space=1,Linear=0,sRGB=1
--track1:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@thresholding:
--#include "shaders/utils.hlsl"
--#include "shaders/threshold.hlsl"
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local threshold = clamp(tonumber(_0.threshold) or obj.track0, 0.0, 255.0) / 255.0
local channel = tonumber(_0.channel) or _1 _1 = nil
local inv = obj.check0 and 1 or 0
if (type(_0.inv) == "boolean") then
    inv = _0.inv and 1 or 0
elseif (type(_0.inv) == "boolean") then
    inv = _0.inv ~= 0 and 1 or 0
end
local light_col = clamp(tonumber(_0.light_col) or _2, 0x000000, 0xffffff) _2 = nil
local light_a = clamp(tonumber(_0.light_a) or obj.track2, 0.0, 100.0) * 0.01
local dark_col = clamp(tonumber(_0.dark_col) or _3, 0x000000, 0xffffff) _3 = nil
local dark_a = clamp(tonumber(_0.dark_a) or obj.track3, 0.0, 100.0) * 0.01
local col_space = tonumber(_0.col_space) or _4 _4 = nil
local mix = clamp(tonumber(_0.mix) or obj.track1, 0.0, 100.0) * 0.01
_0 = nil

obj.pixelshader("thresholding", "object", "object", {
    threshold,
    channel,
    inv,
    light_col,
    light_a,
    dark_col,
    dark_a,
    col_space,
    mix
})


@Threshold(RGBA)
--information:Threshold(RGBA)${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--track0:R Threshold,0,255,128
--track1:G Threshold,0,255,128
--track2:B Threshold,0,255,128
--track3:A Threshold,0,255,128
--check@_1:Invert R,0
--check@_2:Invert G,0
--check@_3:Invert B,0
--check@_4:Invert A,0
--check0:Disable A Threshold,0
--select@_5:Color Space=1,Linear=0,sRGB=1
--track@_6:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@thresholding_rgba:
--#include "shaders/utils.hlsl"
--#include "shaders/threshold_rgba.hlsl"
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local r_threshold = clamp(tonumber(_0.r_threshold) or obj.track0, 0.0, 255.0) / 255.0
local g_threshold = clamp(tonumber(_0.g_threshold) or obj.track1, 0.0, 255.0) / 255.0
local b_threshold = clamp(tonumber(_0.b_threshold) or obj.track2, 0.0, 255.0) / 255.0
local a_threshold = clamp(tonumber(_0.a_threshold) or obj.track3, 0.0, 255.0) / 255.0
local inv_r = _1 _1 = nil
if (type(_0.inv_r) == "boolean") then
    inv_r = _0.inv_r and 1 or 0
elseif (type(_0.inv_r) == "number") then
    inv_r = _0.inv_r ~= 0 and 1 or 0
end
local inv_g = _2 _2 = nil
if (type(_0.inv_g) == "boolean") then
    inv_g = _0.inv_g and 1 or 0
elseif (type(_0.inv_g) == "number") then
    inv_g = _0.inv_g ~= 0 and 1 or 0
end
local inv_b = _3 _3 = nil
if (type(_0.inv_b) == "boolean") then
    inv_b = _0.inv_b and 1 or 0
elseif (type(_0.inv_b) == "number") then
    inv_b = _0.inv_b ~= 0 and 1 or 0
end
local inv_a = _4 _4 = nil
if (type(_0.inv_a) == "boolean") then
    inv_a = _0.inv_a and 1 or 0
elseif (type(_0.inv_a) == "number") then
    inv_a = _0.inv_a ~= 0 and 1 or 0
end
local disable_a = obj.check0 and 1 or 0
if (type(_0.disable_a) == "boolean") then
    disable_a = _0.disable_a and 1 or 0
elseif (type(_0.disable_a) == "number") then
    disable_a = disable_a ~= 0 and 1 or 0
end
local col_space = tonumber(_0.col_space) or _5 _5 = nil
local mix = clamp(tonumber(_0.mix) or _6, 0.0, 100.0) * 0.01 _6 = nil
_0 = nil

obj.pixelshader("thresholding_rgba", "object", "object", {
    r_threshold, g_threshold, b_threshold, a_threshold,
    inv_r, inv_g, inv_b, inv_a,
    disable_a,
    col_space,
    mix
})


@Posterize
--information:Posterize${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--track0:Level,1,256,8,1
--select@_1:Channel,RGB=0,RGBA=1,Value=2,Value A=3
--track@_2:Size,1,2000,1,1
--check@_5:Sharp Colors,0
--select@_3:Color Space=1,Linear=0,sRGB=1
--track@_4:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@posterize:
--#include "shaders/utils.hlsl"
--#include "shaders/posterize.hlsl"
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local level = clamp(math.floor(tonumber(_0.level) or obj.track0), 1, 256)
local channel = tonumber(_0.channel) or _1 _1 = nil
local size = math.max(math.floor(tonumber(_0.size) or _2), 1) _2 = nil
local sharp_col = _5 _5 = nil
if (type(_0.sharp_col) == "boolean") then
    sharp_col = _0.sharp_col and 1 or 0
elseif (type(_0.sharp_col) == "number") then
    sharp_col = _0.sharp_col ~= 0 and 1 or 0
end
local col_space = tonumber(_0.col_space) or _3 _3 = nil
local mix = clamp(tonumber(_0.mix) or _4, 0.0, 100.0) * 0.01 _4 = nil
_0 = nil

if (size > 1) then
    local w, h = obj.getpixel()
    local mosaic_params = string.format("bx = %d, by = %d, sharp_col = %d", w / size, h / size, sharp_col)
    obj.effect("Mosaic@Stylize_K", "PI", mosaic_params)
end

obj.pixelshader("posterize", "object", "object", {
    level,
    channel,
    col_space,
    mix
})


@Posterize(RGBA)
--information:Posterize(RGBA)${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--track0:R Level,1,256,8,1
--track1:G Level,1,256,8,1
--track2:B Level,1,256,8,1
--track3:A Level,1,256,8,1
--check0:Disable A Level,0
--track@_1:Size,1,2000,1,1
--check@_2:Sharp Colors,0
--select@_3:Color Space=1,Linear=0,sRGB=1
--track@_4:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@posterize_rgba:
--#include "shaders/utils.hlsl"
--#include "shaders/posterize_rgba.hlsl"
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local r_level = clamp(math.floor(tonumber(_0.r_level) or obj.track0), 1, 256)
local g_level = clamp(math.floor(tonumber(_0.g_level) or obj.track1), 1, 256)
local b_level = clamp(math.floor(tonumber(_0.b_level) or obj.track2), 1, 256)
local a_level = clamp(math.floor(tonumber(_0.a_level) or obj.track3), 1, 256)
local disable_a = obj.check0 and 1 or 0
if (type(_0.disable_a) == "boolean") then
    disable_a = _0.disable_a and 1 or 0
elseif (type(_0.disable_a) == "number") then
    disable_a = disable_a ~= 0 and 1 or 0
end
local size = math.max(math.floor(tonumber(_0.size) or _1), 1) _1 = nil
local sharp_col = _2 _2 = nil
if (type(_0.sharp_col) == "boolean") then
    sharp_col = _0.sharp_col and 1 or 0
elseif (type(_0.sharp_col) == "number") then
    sharp_col = _0.sharp_col ~= 0 and 1 or 0
end
local col_space = tonumber(_0.col_space) or _3 _3 = nil
local mix = clamp(tonumber(_0.mix) or _4, 0.0, 100.0) * 0.01 _4 = nil
_0 = nil

if (size > 1) then
    local w, h = obj.getpixel()
    local mosaic_params = string.format("bx = %d, by = %d, sharp_col = %d", w / size, h / size, sharp_col)
    obj.effect("Mosaic@Stylize_K", "PI", mosaic_params)
end

obj.pixelshader("posterize_rgba", "object", "object", {
    r_level, g_level, b_level, a_level,
    disable_a,
    col_space,
    mix
})


@ASCII
--information:ASCII${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--value@_1:Glyphs,"@#%*+=-:. "
--font@_2:Font,Yu Gothic UI
--track@_3:Padding,-100,100,0,1
--track0:X Blocks,1,16384,80,1
--track1:Y Blocks,1,16384,45,1
--check0:Sharp Colors,0
--track@_4:Luma Gain,0,1000,100,0.01
--track2:Min Luma,0,100,0,0.01
--track3:Max Luma,0,100,100,0.01
--select@_5:Luma Mode=1,BT.601=0,BT.709=1,BT.2020=2
--check@_6:Invert Luma,1
--select@_7:Glyph Type=0,Solid=0,Original=1,Mosaic=2
--color@_8:Glyph Color,0xffffff
--select@_9:Canvas Type,Transparent=0,Solid=1,Original=2,Mosaic=3
--color@_10:Canvas Color,0x000000
--select@_11:Color Space=1,Linear=0,sRGB=1
--select@_12:Alpha,None=0,Premultiplied=1
--select@_13:Blend Mode,Normal=0,Add=1,Subtract=2,Multiply=3,Screen=4,Overlay=5,Lighten=6,Darken=7,Luminosity=8,Chroma=9,Linear Burn=10,Linear Light=11,Difference=12
--track@_14:Mix,0,100,100,0.01
--check@_15:Shuffle Glyphs,0
--value@_16:Excluded Glyphs,""
--track@_17:Interval,0,100,0,1
--track@_18:Seed,-1000,1000,-1,1
--value@_0:PI,{}
--[[pixelshader@ascii:
--#include "shaders/utils.hlsl"
--#include "shaders/ascii.hlsl"
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local glyphs_str = _0.glyphs and tostring(_0.glyphs) or _1 _1 = nil
local font = _0.font and tostring(_0.font) or _2 _2 = nil
local padding = math.floor(tonumber(_0.padding) or _3) _3 = nil
local bx = clamp(math.floor(tonumber(_0.bx) or obj.track0), 1, 16384)
local by = clamp(math.floor(tonumber(_0.by) or obj.track1), 1, 16384)
local sharp_col = obj.check0 and 1 or 0
if (type(_0.sharp_col) == "boolean") then
    sharp_col = _0.sharp_col and 1 or 0
elseif (type(_0.sharp_col) == "number") then
    sharp_col = _0.sharp_col ~= 0 and 1 or 0
end
local luma_gain = math.max(tonumber(_0.luma_gain) or _4, 0.0) * 0.01 _4 = nil
local min_luma = clamp(tonumber(_0.min_luma) or obj.track2, 0.0, 100.0) * 0.01
local max_luma = clamp(tonumber(_0.max_luma) or obj.track3, 0.0, 100.0) * 0.01
local luma_mode = tonumber(_0.luma_mode) or _5 _5 = nil
local inv_luma = _6 _6 = nil
if (type(_0.inv_luma) == "boolean") then
    inv_luma = _0.inv_luma and 1 or 0
elseif (type(_0.inv_luma) == "number") then
    inv_luma = _0.inv_luma ~= 0 and 1 or 0
end
local glyph_type = tonumber(_0.glyph_type) or _7 _7 = nil
local glyph_col = clamp(tonumber(_0.glyph_col) or _8, 0x000000, 0xffffff) _8 = nil
local canvas_type = tonumber(_0.canvas_type) or _9 _9 = nil
local canvas_col = clamp(tonumber(_0.canvas_col) or _10, 0x000000, 0xffffff) _10 = nil
local col_space = tonumber(_0.col_space) or _11 _11 = nil
local alpha = tonumber(_0.alpha) or _12 _12 = nil
local blend_mode = tonumber(_0.blend_mode) or _13 _13= nil
local mix = clamp(tonumber(_0.mix) or _14, 0.0, 100.0) * 0.01 _14 = nil
local shuf_glyphs = _15 ~= 0 _15 = nil
if (type(_0.shuf_glyphs) == "boolean") then
    shuf_glyphs = _0.shuf_glyphs
elseif (type(_0.shuf_glyphs) == "number") then
    shuf_glyphs = _0.inv_luma ~= 0
end
local exclude_str = _0.excluded_glyphs and tonumber(_0.excluded_glyphs) or _16 _16 = nil
local interval = math.max(tonumber(_0.interval) or _17, 0) _17 = nil
local seed = tonumber(_0.seed) or _18 _18 = nil
_0 = nil

if (glyphs_str == "") then
    debug_print("The text cannot be empty.")
    return
end

local function err_handler(e)
    local hint = "Hint: Try increasing TemporaryImageCacheSize in system.conf."
    debug_print(string.format("%s. %s", e, hint))
end

local function copy_geo(dst, src)
    for k in ("ox, oy, oz, cx, cy, cz, rx, ry, rz, zoom, aspect, alpha"):gmatch("%a+") do
        dst[k] = src[k]
    end
end

local function split_utf8(str)
    local t = {}
    local i = 1
    while i <= #str do
        local byte = string.byte(str, i)
        local len

        if (byte < 0x80) then
            len = 1
        elseif (byte < 0xE0) then
            len = 2
        elseif (byte < 0xF0) then
            len = 3
        else
            len = 4
        end

        table.insert(t, string.sub(str, i, i + len - 1))
        i = i + len
    end
    return t
end

local function shuffle(t, exclude)
    local set = {}
    for _, v in ipairs(exclude or {}) do
        set[v] = true
    end

    local indices = {}
    local len = 0
    for i = 1, #t do
        if not set[t[i]] then
            len = len + 1
            indices[len] = i
        end
    end

    local f = interval > 0 and math.floor(obj.frame / interval) or 0
    for i = len, 2, -1 do
        local j = obj.rand(1, i, seed, f)
        local m, n = indices[i], indices[j]
        t[m], t[n] = t[n], t[m]
    end
end

local ok, e = pcall(function()
    local geo = {}
    local blend = glyph_type == 1 and "mask" or "copy"
    local col_list = {0xff0000, 0x00ff00, 0x0000ff}
    local w, h = obj.getpixel()
    local max_w, max_h = obj.getinfo("image_max")
    local bw, bh = math.floor(w / bx), math.floor(h / by)
    local mosaic_params = string.format("bx = %d, by = %d, sharp_col = %d", bx, by, sharp_col)
    local size = math.max(math.min(bw, bh) - padding * 2, 0)
    local glyphs = split_utf8(glyphs_str)
    local exclude = split_utf8(exclude_str)
    local len = #glyphs
    local map_w, map_h = bw * math.ceil(len / 3.0), bh
    if (map_w > max_w or map_h > max_h) then
        debug_print("The font size is too large or the text is too long.")
        return
    end

    copy_geo(geo, obj)
    obj.copybuffer("cache:img", "object")
    obj.effect("Mosaic@Stylize_K", "PI", mosaic_params)
    obj.copybuffer("cache:mosaic", "object")

    obj.setoption("drawtarget", "tempbuffer", map_w, map_h)
    obj.setoption("blend", 1)
    if (shuf_glyphs) then
        shuffle(glyphs, exclude)
    end

    local a = -0.5 * (map_w - bw)
    for i = 1, len do
        local idx = i - 1
        obj.setfont(font, size, 0, col_list[(idx % 3) + 1])
        obj.load("text", glyphs[i])
        obj.draw(a + bw * (math.floor(idx / 3)))
    end

    obj.copybuffer("object", "cache:img")
    obj.pixelshader("ascii", "object", {
        "cache:mosaic",
        "tempbuffer"
    }, {
        bx, by,
        w, h,
        map_w, map_h,
        min_luma, max_luma,
        len,
        luma_gain,
        luma_mode,
        inv_luma,
        glyph_type,
        glyph_col,
        col_space,
        alpha
    }, blend)

    if (canvas_type == 1) then
        obj.setoption("drawtarget", "tempbuffer", w, h)
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")

        obj.copybuffer("cache:ascii", "object")
        obj.load("figure", "四角形", canvas_col, 1)
        local half_w, half_h = w * 0.5, h * 0.5
        obj.drawpoly(
            -half_w, -half_h, 0,
            half_w,  -half_h, 0,
            half_w,  half_h,  0,
            -half_w, half_h,  0
        )
        obj.copybuffer("object", "cache:ascii")
    elseif (canvas_type == 2) then
        obj.copybuffer("tempbuffer", "cache:img")
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")
    elseif (canvas_type == 3) then
        obj.copybuffer("tempbuffer", "cache:mosaic")
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")
    else
        obj.setoption("drawtarget", "tempbuffer", w, h)
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")
    end

    obj.setoption("blend", blend_mode)
    obj.draw(0, 0, 0, 1, mix)
    obj.setoption("blend", 0)

    obj.load("tempbuffer")
    obj.clearbuffer("tempbuffer")
    copy_geo(obj, geo)
end)
if (not ok) then
    err_handler(e)
end


@MotionTile
--information:MotionTile${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}\Tile
--track2:Width Scale,0,10000,100,0.01
--track3:Height Scale,0,10000,100,0.01
--select@s0:Mirror Direction,None=0,Horizontal=1,Vertical=2,Both=3
--group:Transform,false
--track0:X Center,-4000,4000,0,0.01
--track1:Y Center,-4000,4000,0,0.01
--track4:X Scale,0,10000,100,0.01
--track5:Y Scale,0,10000,100,0.01
--track6:Rotation,-3600,3600,0,0.01
--group:Phase Shift,false
--track7:Phase,-3600,3600,0,0.01
--select@s1:Phase Direction=1,Horizontal=0,Vertical=1
--group:Additional Options,false
--value@_0:PI,{}
--[[pixelshader@motion_tile:
--#include "shaders/motion_tile.hlsl"
]]

obj.setanchor("track", 0, "line")

_0 = _0 or {}
local sw = obj.track2
local sh = obj.track3
local sx = obj.track4
local sy = obj.track5

if (type(_0.scale) == "table") then
    sw = tonumber(_0.scale.w) or obj.track2
    sh = tonumber(_0.scale.h) or obj.track3
    sx = tonumber(_0.scale.x) or obj.track4
    sy = tonumber(_0.scale.y) or obj.track5
end

sw = sw * 0.01
sh = sh * 0.01
sx = sx * 0.01
sy = sy * 0.01

local cx = obj.track0
local cy = obj.track1

if (type(_0.center) == "table") then
    cx = tonumber(_0.center.x) or obj.track0
    cy = tonumber(_0.center.y) or obj.track1
end

cx = cx / obj.w
cy = cy / obj.h

local phase = obj.track7
local phase_dir = s1
if (type(_0.phase_shift) == "table") then
    phase = tonumber(_0.phase_shift.phase) or obj.track7
    phase_dir = tonumber(_0.phase_shift.direction) or s1
end
s1 = nil

local rot = math.rad(tonumber(_0.rotation) or obj.track6)
local mirror = tonumber(_0.mirror_direction) or s0 s0 = nil
_0 = nil

--#include "utils.lua"

local geo = {}
local max_w, max_h = obj.getinfo("image_max")
local w = math.min(math.floor(obj.w * sw), max_w)
local h = math.min(math.floor(obj.h * sh), max_h)

if (w * h < 1) then
    obj.effect("リサイズ", "拡大率", 0)
    return
end

sw = w / obj.w
sh = h / obj.h

local c = math.cos(rot)
local s = math.sin(rot)

copy_geo(geo, obj)
obj.setoption("drawtarget", "tempbuffer", w, h)

obj.pixelshader("motion_tile", "tempbuffer", "object", {
    c, -s, 0.0, 0.0,
    s,  c,
    sw * 0.5 + cx, sh * 0.5 + cy,
    sw, sh,
    sx, sy,
    bit.band(mirror, 1), bit.rshift(mirror, 1),
    1 - phase_dir, phase_dir,
    phase / 360.0,
    obj.h / obj.w
}, "copy", "clamp")

obj.load("tempbuffer")
obj.clearbuffer("tempbuffer")
copy_geo(obj, geo)


@Tile
--information:Tile${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}\Tile
--group:Count
--track0:X Count,1,1000,3,1
--track1:Y Count,1,1000,3,1
--track2:Z Count,1,1000,1,1
--group:Padding
--select@s0:Padding Mode,Relative=0,Absolute=1,Bounds=2
--track3:X Padding,-100000,100000,0,0.01
--track4:Y Padding,-100000,100000,0,0.01
--track5:Z Padding,-100000,100000,0,0.01
--group:Offset,false
--select@s1:Offset Mode,Relative=0,Absolute=1,Endpoint=2
--track6:X Offset,-100000,100000,0,0.01
--track7:Y Offset,-100000,100000,0,0.01
--track8:Z Offset,-100000,100000,0,0.01
--group:Alignment,false
--select@s4:X Axis=1,Minimum=0,Center=1,Maximum=2
--select@s5:Y Axis=1,Minimum=0,Center=1,Maximum=2
--select@s6:Z Axis=1,Minimum=0,Center=1,Maximum=2
--group:Additional Options,false
--select@s7:Coord Space=1,World=0,Local=1
--value@_0:PI,{}

_0 = _0 or {}
local count = {
    x = obj.track0 - 1,
    y = obj.track1 - 1,
    z = obj.track2 - 1
}

if (type(_0.count) == "table") then
    count.x = (tonumber(_0.count.x) or obj.track0) - 1
    count.y = (tonumber(_0.count.y) or obj.track1) - 1
    count.z = (tonumber(_0.count.z) or obj.track2) - 1
end

local padding = {
    mode = s0,
    x = obj.track3,
    y = obj.track4,
    z = obj.track5
}

if (type(_0.padding) == "table") then
    padding.mode = tonumber(_0.padding.mode) or s0
    padding.x = tonumber(_0.padding.x) or obj.track3
    padding.y = tonumber(_0.padding.y) or obj.track4
    padding.z = tonumber(_0.padding.z) or obj.track5
end
s0 = nil

local offset = {
    mode = s1,
    x = obj.track6,
    y = obj.track7,
    z = obj.track8
}

if (type(_0.offset) == "table") then
    offset.mode = tonumber(_0.offset.mode) or s1
    offset.x = tonumber(_0.offset.x) or obj.track6
    offset.y = tonumber(_0.offset.y) or obj.track7
    offset.z = tonumber(_0.offset.z) or obj.track8
end
s1 = nil

local align = {
    x = s4,
    y = s5,
    z = s6
}

if (type(_0.alignment) == "table") then
    align.x = tonumber(_0.alignment.x) or s4
    align.y = tonumber(_0.alignment.y) or s5
    align.z = tonumber(_0.alignment.z) or s6
end
s4 = nil
s5 = nil
s6 = nil

local size = {
    x = obj.w,
    y = obj.h,
    z = 0.0
}

if (type(_0.size) == "table") then
    size.x = tonumber(_0.size.x) or obj.w
    size.y = tonumber(_0.size.y) or obj.h
    size.z = tonumber(_0.size.z) or 0.0
end

local space = tonumber(_0.coord_space) or s7 s7 = nil
_0 = nil

if (space == 0) then
    size.x = size.x * obj.getvalue("sx") * obj.sx
    size.y = size.y * obj.getvalue("sy") * obj.sy
    size.z = size.z * obj.getvalue("sz") * obj.sz
end

local d = {}
if (padding.mode == 0) then
    d.x = size.x * (1.0 + padding.x * 0.01)
    d.y = size.y * (1.0 + padding.y * 0.01)
    d.z = size.z * (1.0 + padding.z * 0.01)
elseif (padding.mode == 2) then
    d.x = (padding.x - size.x) / math.max(count.x, 1.0)
    d.y = (padding.y - size.y) / math.max(count.y, 1.0)
    d.z = (padding.z - size.z) / math.max(count.z, 1.0)
else
    d.x = size.x + padding.x
    d.y = size.y + padding.y
    d.z = size.z + padding.z
end

local o = {}
if (offset.mode == 0) then
    o.x = size.x * (offset.x * 0.01)
    o.y = size.y * (offset.y * 0.01)
    o.z = size.z * (offset.z * 0.01)
elseif (offset.mode == 2) then
    o.x = offset.x / math.max(count.y + count.z, 1.0)
    o.y = offset.y / math.max(count.z + count.x, 1.0)
    o.z = offset.z / math.max(count.x + count.y, 1.0)
else
    o.x = offset.x
    o.y = offset.y
    o.z = offset.z
end

local a = {
    x = -align.x * (0.5 * d.x * count.x + o.x),
    y = -align.y * (0.5 * d.y * count.y + o.y),
    z = -align.z * (0.5 * d.z * count.z + o.z)
}

obj.effect()
if (space == 1) then
    local polys = {}
    local pivot = {
        x = obj.w * 0.5,
        y = obj.h * 0.5
    }

    for k = 0, count.z do
        local z = a.z + d.z * k

        for i = 0, count.x do
            local x = a.x + d.x * i

            for j = 0, count.y do
                local y = a.y + d.y * j

                local ox = x + o.x * (j + k)
                local oy = y + o.y * (k + i)
                local oz = z + o.z * (i + j)

                local l = ox - pivot.x
                local r = ox + pivot.x
                local t = oy - pivot.y
                local b = oy + pivot.y

                table.insert(polys, {
                    l, t, oz,
                    r, t, oz,
                    r, b, oz,
                    l, b, oz,
                    0,     0,
                    obj.w, 0,
                    obj.w, obj.h,
                    0,     obj.h
                })
            end
        end
    end

    obj.drawpoly(polys)
else
    for k = 0, count.z do
        local z = a.z + d.z * k

        for i = 0, count.x do
            local x = a.x + d.x * i

            for j = 0, count.y do
                local y = a.y + d.y * j

                local ox = x + o.x * (j + k)
                local oy = y + o.y * (k + i)
                local oz = z + o.z * (i + j)

                obj.draw(ox, oy, oz)
            end
        end
    end
end


@Repeat
--information:Repeat${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}\Tile
--track@count:Count,1,1000,3,1
--track2:Offset,-100,100,0,0.1
--select@s0:Composite,Below=0,Above=1
--group:Transform Offset
--select@s1:Offset Mode,Relative=0,Absolute=1,Endpoint=2
--track3:X,-100000,100000,100,0.01
--track4:Y,-100000,100000,0,0.01
--track5:X Scale,0,10000,100,0.01
--track6:Y Scale,0,10000,100,0.01
--track7:Rotation,-3600,3600,0,0.01
--track8:Opacity,0,100,100,0.01
--group
--track0:X Center,-100000,100000,0,0.01
--track1:Y Center,-100000,100000,0,0.01
--select@s2:Blend Mode,Normal=0,Add=1,Subtract=2,Multiply=3,Screen=4,Overlay=5,Lighten=6,Darken=7,Luminosity=8,Color=9,Linear Burn=10,Linear Light=11,Difference=12
--group:Additional Options,false
--value@_0:PI,{}

do
obj.setanchor("track", 0, "line")

local max, min, cos, sin, floor, rad = math.max, math.min, math.cos, math.sin, math.floor, math.rad
local setoption = obj.setoption

_0 = _0 or {}
local n = max(floor(tonumber(_0.count) or count), 1) count = nil -- for user
local offset = tonumber(_0.offset) or obj.track2
local composite = tonumber(_0.composite) or s0 s0 = nil
local offset_mode = tonumber(_0.offset_mode) or s1 s1 = nil
local ox = tonumber(_0.x) or obj.track3
local oy = tonumber(_0.y) or obj.track4
local osx = (tonumber(_0.sx) or obj.track5) * 0.01
local osy = (tonumber(_0.sy) or obj.track6) * 0.01
local orz = rad(tonumber(_0.rotation) or obj.track7)
local oa = tonumber(_0.opacity) or obj.track8 * 0.01
local px = tonumber(_0.cx) or obj.track0
local py = tonumber(_0.cy) or obj.track1
local blend = tonumber(_0.blend_mode) or s2 s2 = nil
_0 = nil

local w, h = obj.w, obj.h

local copy, resize, draw
do
    local ceil, abs = math.ceil, math.abs
    local drawpoly = obj.drawpoly

    local tiny = -math.huge

    local hw, hh = w * 0.5, h * 0.5
    local keys = {
        "cx", "cy", "cz",
        "ox", "oy", "oz",
        "rx", "ry", "rz",
        "sx", "sy", "sz",
        "alpha"
    }

    copy = function (dst, src)
        for i = 1, 13 do
            local k = keys[i]
            dst[k] = src[k]
        end
    end

    resize = function (data)
        local top, right, bottom, left = tiny, tiny, tiny, tiny

        for i = 1, n do
            local t = data[i]
            local m11 = t[1]
            local m21 = t[2]
            local m12 = t[3]
            local m22 = t[4]
            local tx = t[5]
            local ty = t[6]

            local x = tx + px - (m11 * px + m12 * py)
            local y = ty + py - (m21 * px + m22 * py)
            local dx = (abs(m11) * hw + abs(m12) * hh) - hw
            local dy = (abs(m21) * hw + abs(m22) * hh) - hh

            top = max(ceil(dy - y), top)
            right = max(ceil(dx + x), right)
            bottom = max(ceil(dy + y), bottom)
            left = max(ceil(dx - x), left)
        end

        return top, right, bottom, left
    end

    draw = function (t, cx, cy)
        local m11 = t[1]
        local m21 = t[2]
        local m12 = t[3]
        local m22 = t[4]
        local tx = t[5]
        local ty = t[6]
        local a = t[7]

        local ur_x = m11 * hw - m12 * hh
        local ur_y = m21 * hw - m22 * hh
        local lr_x = m11 * hw + m12 * hh
        local lr_y = m21 * hw + m22 * hh
        local x = tx + px - (m11 * px + m12 * py) + cx
        local y = ty + py - (m21 * px + m22 * py) + cy

        drawpoly(
            x - lr_x, y - lr_y, 0.0,
            x + ur_x, y + ur_y, 0.0,
            x + lr_x, y + lr_y, 0.0,
            x - ur_x, y - ur_y, 0.0,
            0, 0,
            w, 0,
            w, h,
            0, h,
            a
        )
    end
end

local geo = {}
local data = {}
local st, ed, step
if (composite == 0) then
    st, ed, step = n - 1, 0, -1
else
    st, ed, step = 0, n - 1, 1
end

if (offset_mode == 0) then
    ox, oy = w * ox * 0.01, h * oy * 0.01
elseif (offset_mode == 2 and n > 1) then
    local rn = 1.0 / (n - 1)
    ox, oy, orz = ox * rn, oy * rn, orz * rn
    osx, osy, oa = osx ^ rn, osy ^ rn, oa ^ rn
end

for i = st, ed, step do
    local f = i + offset
    local sx, sy = osx ^ f, osy ^ f
    local rz = orz * f
    local c, s = cos(rz), sin(rz)

    data[#data + 1] = {
        sx * c,  sx * s,
        -sy * s, sy * c,
        ox * f,  oy * f,
        min(oa ^ f, 1.0)
    }
end

local t, r, b, l = resize(data)
local cx, cy = (l - r) * 0.5, (t - b) * 0.5

copy(geo, obj)
setoption("drawtarget", "tempbuffer", w + l + r, h + t + b)
setoption("blend", blend)

for i = 1, n do
    draw(data[i], cx, cy)
end

obj.load("tempbuffer")
obj.clearbuffer("tempbuffer")
setoption("blend", "none")
copy(obj, geo)
obj.cx, obj.cy = obj.cx + cx, obj.cy + cy
end


@Array(Line)
--information:Array(Line)${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}\Tile\Array
--track@count:Count,1,1000,3,1
--track3:Offset,-100,100,0,0.1
--group:Transform Offset
--select@s0:Offset Mode,Relative=0,Absolute=1,Endpoint=2
--track0:X,-100000,100000,100,0.01
--track1:Y,-100000,100000,0,0.01
--track2:Z,-100000,100000,0,0.01
--track4:X Rotation,-3600,3600,0,0.01
--track5:Y Rotation,-3600,3600,0,0.01
--track6:Z Rotation,-3600,3600,0,0.01
--track7:X Scale,0,10000,100,0.01
--track8:Y Scale,0,10000,100,0.01
--track9:Z Scale,0,10000,100,0.01
--group:Randomization,false
--check0:Randomize,0
--track10:X Extent,-100000,100000,0,0.01
--track11:Y Extent,-100000,100000,0,0.01
--track12:Z Extent,-100000,100000,0,0.01
--track13:RX Extent,-3600,3600,0,0.01
--track14:RY Extent,-3600,3600,0,0.01
--track15:RZ Extent,-3600,3600,0,0.01
--track16:SX Extent,0,100,0,0.01
--track17:SY Extent,0,100,0,0.01
--track18:SZ Extent,0,100,0,0.01
--track19:X Flipping,0,100,0,0.01
--track20:Y Flipping,0,100,0,0.01
--track21:Z Flipping,0,100,0,0.01
--select@s1:Exclusion,None=0,First=1,Last=2,Both=3
--track22:Seed,0,1000,0,1
--group:Additional Options,false
--value@_0:PI,{}

do
if (s0 == 2) then
    obj.setanchor("track", 0, "line", "xyz")
end

local function tobool(v, d)
    if (type(v) == "boolean") then
        return v
    elseif (type(v) == "number") then
        return v ~= 0
    else
        return d
    end
end

local max, cos, sin, floor, rad = math.max, math.cos, math.sin, math.floor, math.rad

_0 = _0 or {}
local n = max(floor(tonumber(_0.count) or count), 1) - 1 count = nil -- for user
local offset = tonumber(_0.offset) or obj.track3
local offset_mode = tonumber(_0.offset_mode) or s0 s0 = nil
local ox = tonumber(_0.x) or obj.track0
local oy = tonumber(_0.y) or obj.track1
local oz = tonumber(_0.z) or obj.track2
local orx = rad(tonumber(_0.rx) or obj.track4)
local ory = rad(tonumber(_0.ry) or obj.track5)
local orz = rad(tonumber(_0.rz) or obj.track6)
local osx = (tonumber(_0.sx) or obj.track7) * 0.01
local osy = (tonumber(_0.sy) or obj.track8) * 0.01
local osz = (tonumber(_0.sz) or obj.track9) * 0.01
local randomize = tobool(_0.randomize, obj.check0)
local x_ex, y_ex, z_ex
local rx_ex, ry_ex, rz_ex
local sx_ex, sy_ex, sz_ex
local fx, fy, fz
local skip_f, skip_l
if (randomize) then
    x_ex = tonumber(_0.x_extent) or obj.track10
    y_ex = tonumber(_0.y_extent) or obj.track11
    z_ex = tonumber(_0.z_extent) or obj.track12
    rx_ex = rad(tonumber(_0.rx_extent) or obj.track13)
    ry_ex = rad(tonumber(_0.ry_extent) or obj.track14)
    rz_ex = rad(tonumber(_0.rz_extent) or obj.track15)
    sx_ex = (tonumber(_0.sx_extent) or obj.track16) * 0.01
    sy_ex = (tonumber(_0.sy_extent) or obj.track17) * 0.01
    sz_ex = (tonumber(_0.sz_extent) or obj.track18) * 0.01
    fx = (tonumber(_0.x_flipping) or obj.track19) * 0.01
    fy = (tonumber(_0.y_flipping) or obj.track20) * 0.01
    fz = (tonumber(_0.z_flipping) or obj.track21) * 0.01
    math.randomseed(tonumber(_0.seed) or obj.track22)
    local exclusion = tonumber(_0.exclusion) or s1 s1 = nil
    skip_f, skip_l = bit.band(exclusion, 1) ~= 0, bit.rshift(exclusion, 1) ~= 0
end
_0 = nil

local totransform, fk, bbox, draw
do
    local min, abs = math.min, math.abs

    local huge = math.huge
    local tiny = -huge

    totransform = function (x, y, z, rx, ry, rz, sx, sy, sz)
        local c0, s0 = cos(rx), sin(rx)
        local c1, s1 = cos(ry), sin(ry)
        local c2, s2 = cos(rz), sin(rz)

        return {
            sx * (c1 * c2),  sx * (c0 * s2 + s0 * s1 * c2), sx * (s0 * s2 - c0 * s1 * c2),
            sy * (-c1 * s2), sy * (c0 * c2 - s0 * s1 * s2), sy * (s0 * c2 + c0 * s1 * s2),
            sz * (s1),       sz * (-s0 * c1),               sz * (c0 * c1)               ,
            x,               y,                             z
        }
    end

    fk = function (t0, t1)
        local t = {}

        for j = 1, 7, 3 do
            local x, y, z = t1[j], t1[j + 1], t1[j + 2]
            for i = 1, 3 do
                t[#t + 1] = t0[i] * x + t0[i + 3] * y + t0[i + 6] * z
            end
        end

        local x, y, z = t1[10], t1[11], t1[12]
        for i = 1, 3 do
            t[#t + 1] = t0[i] * x + t0[i + 3] * y + t0[i + 6] * z + t0[i + 9]
        end

        return t
    end

    bbox = function (data, cx, cy, cz)
        local hw, hh = obj.w * 0.5, obj.h * 0.5

        local x_min, x_max = huge, tiny
        local y_min, y_max = huge, tiny
        local z_min, z_max = huge, tiny

        local len = #data
        for i = 1, len do
            local t = data[i]
            local m11 = t[1]
            local m21 = t[2]
            local m31 = t[3]
            local m12 = t[4]
            local m22 = t[5]
            local m32 = t[6]
            local m13 = t[7]
            local m23 = t[8]
            local m33 = t[9]
            local tx = t[10]
            local ty = t[11]
            local tz = t[12]

            local x = tx + cx - (m11 * cx + m12 * cy + m13 * cz)
            local y = ty + cy - (m21 * cx + m22 * cy + m23 * cz)
            local z = tz + cz - (m31 * cx + m32 * cy + m33 * cz)
            local vx = abs(m11) * hw + abs(m12) * hh
            local vy = abs(m21) * hw + abs(m22) * hh
            local vz = abs(m31) * hw + abs(m32) * hh

            x_min, x_max = min(x - vx, x_min), max(x + vx, x_max)
            y_min, y_max = min(y - vy, y_min), max(y + vy, y_max)
            z_min, z_max = min(z - vz, z_min), max(y + vy, y_max)
        end

        return x_max - x_min, y_max - y_min, z_max - z_min
    end

    draw = function (data, cx, cy, cz)
        local w, h = obj.w, obj.h
        local hw, hh = w * 0.5, h * 0.5

        local polys = {}

        local len = #data
        for i = 1, len do
            local t = data[i]
            local m11 = t[1]
            local m21 = t[2]
            local m31 = t[3]
            local m12 = t[4]
            local m22 = t[5]
            local m32 = t[6]
            local m13 = t[7]
            local m23 = t[8]
            local m33 = t[9]
            local tx = t[10]
            local ty = t[11]
            local tz = t[12]

            local ur_x = m11 * hw - m12 * hh
            local ur_y = m21 * hw - m22 * hh
            local ur_z = m31 * hw - m32 * hh
            local lr_x = m11 * hw + m12 * hh
            local lr_y = m21 * hw + m22 * hh
            local lr_z = m31 * hw + m32 * hh
            local x = tx + cx - (m11 * cx + m12 * cy + m13 * cz)
            local y = ty + cy - (m21 * cx + m22 * cy + m23 * cz)
            local z = tz + cz - (m31 * cx + m32 * cy + m33 * cz)

            polys[#polys + 1] = {
                x - lr_x, y - lr_y, z - lr_z,
                x + ur_x, y + ur_y, z + ur_z,
                x + lr_x, y + lr_y, z + lr_z,
                x - ur_x, y - ur_y, z - ur_z,
                0, 0,
                w, 0,
                w, h,
                0, h,
            }
        end

        obj.drawpoly(polys)
    end
end

if (offset_mode == 0) then
    local bx, by, bz
    if (_G["STYLIZE_ARRAY"] == nil) then
        bx, by, bz = obj.w, obj.h, 0.0
    else
        local cx, cy, cz = obj.getvalue("cx") + obj.cx, obj.getvalue("cy") + obj.cy, obj.getvalue("cz") + obj.cz
        bx, by, bz = bbox(_G["STYLIZE_ARRAY"], cx, cy, cz)
    end
    ox, oy, oz = bx * ox * 0.01, by * oy * 0.01, bz * oz * 0.01
elseif (offset_mode == 2 and n > 0) then
    local rn = 1.0 / n
    ox, oy, oz = ox * rn, oy * rn, oz * rn
    orx, ory, orz = orx * rn, ory * rn, orz * rn
    osx, osy, osz = osx ^ rn, osy ^ rn, osz ^ rn
end

if (_G["STYLIZE_ARRAY"] == nil) then
    _G["STYLIZE_ARRAY"] = { { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 } }
end

local dst = {}
local src = _G["STYLIZE_ARRAY"]
local len = #src
for i = 0, n do
    local f = i + offset
    local x, y, z = ox * f, oy * f, oz * f
    local rx, ry, rz = orx * f, ory * f, orz * f
    local sx, sy, sz = osx ^ f, osy ^ f, osz ^ f

    local rand = randomize and not ((i == 0 and skip_f) or (i == n and skip_l))

    if (rand) then
        x = x + (math.random() * 2.0 - 1.0) * x_ex
        y = y + (math.random() * 2.0 - 1.0) * y_ex
        z = z + (math.random() * 2.0 - 1.0) * z_ex
        rx = rx + (math.random() * 2.0 - 1.0) * rx_ex
        ry = ry + (math.random() * 2.0 - 1.0) * ry_ex
        rz = rz + (math.random() * 2.0 - 1.0) * rz_ex
        sx = sx * (1.0 - math.random() * sx_ex)
        sy = sy * (1.0 - math.random() * sy_ex)
        sz = sz * (1.0 - math.random() * sz_ex)
        sx = math.random() < fx and -sx or sx
        sy = math.random() < fy and -sy or sy
        sz = math.random() < fz and -sz or sz
    end

    local t = totransform(x, y, z, rx, ry, rz, sx, sy, sz)

    for j = 1, len do
        dst[#dst + 1] = fk(t, src[j])
    end
end
_G["STYLIZE_ARRAY"] = dst

if (not obj.getoption("script_name", 1, true):match("^Array(.*)${SCRIPT_NAME}$")) then
    obj.effect()

    local cx, cy, cz = obj.getvalue("cx") + obj.cx, obj.getvalue("cy") + obj.cy, obj.getvalue("cz") + obj.cz
    draw(_G["STYLIZE_ARRAY"], cx, cy, cz)

    _G["STYLIZE_ARRAY"] = nil
    obj.setoption("focus_mode", "fixed_size")
end
end


@Array(Circle)
--information:Array(Circle)${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}\Tile\Array
--track@count:Count,1,1000,3,1
--track0:Offset,-100,100,0,0.1
--select@s0:Layout,Circle=0,Arc=2
--track1:Radius,0,100000,0,0.01
--track2:Sweep Angle,-3600,3600,360,0.01
--select@s1:Central Axis=3,X=1,Y=2,Z=3
--group:Alignment,false
--check0:Align Rotation,1
--select@s2:Normal Axis,X=0,Y=3,Z=6
--select@s3:Tangent Axis=3,X=0,Y=3,Z=6
--group:Randomization,false
--check1:Randomize,0
--track3:X Extent,-100000,100000,0,0.01
--track4:Y Extent,-100000,100000,0,0.01
--track5:Z Extent,-100000,100000,0,0.01
--track6:RX Extent,-3600,3600,0,0.01
--track7:RY Extent,-3600,3600,0,0.01
--track8:RZ Extent,-3600,3600,0,0.01
--track9:SX Extent,0,100,0,0.01
--track10:SY Extent,0,100,0,0.01
--track11:SZ Extent,0,100,0,0.01
--track12:X Flipping,0,100,0,0.01
--track13:Y Flipping,0,100,0,0.01
--track14:Z Flipping,0,100,0,0.01
--select@s4:Exclusion,None=0,First=1,Last=2,Both=3
--track15:Seed,0,1000,0,1
--group:Additional Options,false
--value@_0:PI,{}

do
local max, cos, sin, floor, rad = math.max, math.cos, math.sin, math.floor, math.rad

local function tobool(v, d)
    if (type(v) == "boolean") then
        return v
    elseif (type(v) == "number") then
        return v ~= 0
    else
        return d
    end
end

_0 = _0 or {}
local n = max(floor(tonumber(_0.count) or count), 1) - 1 count = nil -- for user
local offset = tonumber(_0.offset) or obj.track0
local layout = tonumber(_0.layout) or s0 s0 = nil
local radius = tonumber(_0.radius) or obj.track1
local sweep = rad(tonumber(_0.sweep_angle) or obj.track2)
local central_axis = tonumber(_0.central_axis) or s1 s1 = nil
local align = tobool(_0.align_rotation, obj.check0)
local norm_axis = tonumber(_0.normal_axis) or s2 s2 = nil
local tan_axis = tonumber(_0.tangent_axis) or s3 s3 = nil
local randomize = tobool(_0.randomize, obj.check1)
local x_ex, y_ex, z_ex
local rx_ex, ry_ex, rz_ex
local sx_ex, sy_ex, sz_ex
local fx, fy, fz
local skip_f, skip_l
if (randomize) then
    x_ex = tonumber(_0.x_extent) or obj.track3
    y_ex = tonumber(_0.y_extent) or obj.track4
    z_ex = tonumber(_0.z_extent) or obj.track5
    rx_ex = rad(tonumber(_0.rx_extent) or obj.track6)
    ry_ex = rad(tonumber(_0.ry_extent) or obj.track7)
    rz_ex = rad(tonumber(_0.rz_extent) or obj.track8)
    sx_ex = (tonumber(_0.sx_extent) or obj.track9) * 0.01
    sy_ex = (tonumber(_0.sy_extent) or obj.track10) * 0.01
    sz_ex = (tonumber(_0.sz_extent) or obj.track11) * 0.01
    fx = (tonumber(_0.x_flipping) or obj.track12) * 0.01
    fy = (tonumber(_0.y_flipping) or obj.track13) * 0.01
    fz = (tonumber(_0.z_flipping) or obj.track14) * 0.01
    math.randomseed(tonumber(_0.seed) or obj.track15)
    local exclusion = tonumber(_0.exclusion) or s4 s4 = nil
    skip_f, skip_l = bit.band(exclusion, 1) ~= 0, bit.rshift(exclusion, 1) ~= 0
end
_0 = nil

local totransform, fk, draw
do
    totransform = function (x, y, z, rx, ry, rz, sx, sy, sz)
        local c0, s0 = cos(rx), sin(rx)
        local c1, s1 = cos(ry), sin(ry)
        local c2, s2 = cos(rz), sin(rz)

        return {
            sx * (c1 * c2),  sx * (c0 * s2 + s0 * s1 * c2), sx * (s0 * s2 - c0 * s1 * c2),
            sy * (-c1 * s2), sy * (c0 * c2 - s0 * s1 * s2), sy * (s0 * c2 + c0 * s1 * s2),
            sz * (s1),       sz * (-s0 * c1),               sz * (c0 * c1)               ,
            x,               y,                             z
        }
    end

    fk = function (t0, t1)
        local t = {}

        for j = 1, 7, 3 do
            local x, y, z = t1[j], t1[j + 1], t1[j + 2]
            for i = 1, 3 do
                t[#t + 1] = t0[i] * x + t0[i + 3] * y + t0[i + 6] * z
            end
        end

        local x, y, z = t1[10], t1[11], t1[12]
        for i = 1, 3 do
            t[#t + 1] = t0[i] * x + t0[i + 3] * y + t0[i + 6] * z + t0[i + 9]
        end

        return t
    end

    draw = function (data, cx, cy, cz)
        local w, h = obj.w, obj.h
        local hw, hh = w * 0.5, h * 0.5

        local polys = {}

        local len = #data
        for i = 1, len do
            local t = data[i]
            local m11 = t[1]
            local m21 = t[2]
            local m31 = t[3]
            local m12 = t[4]
            local m22 = t[5]
            local m32 = t[6]
            local m13 = t[7]
            local m23 = t[8]
            local m33 = t[9]
            local tx = t[10]
            local ty = t[11]
            local tz = t[12]

            local ur_x = m11 * hw - m12 * hh
            local ur_y = m21 * hw - m22 * hh
            local ur_z = m31 * hw - m32 * hh
            local lr_x = m11 * hw + m12 * hh
            local lr_y = m21 * hw + m22 * hh
            local lr_z = m31 * hw + m32 * hh
            local x = tx + cx - (m11 * cx + m12 * cy + m13 * cz)
            local y = ty + cy - (m21 * cx + m22 * cy + m23 * cz)
            local z = tz + cz - (m31 * cx + m32 * cy + m33 * cz)

            polys[#polys + 1] = {
                x - lr_x, y - lr_y, z - lr_z,
                x + ur_x, y + ur_y, z + ur_z,
                x + lr_x, y + lr_y, z + lr_z,
                x - ur_x, y - ur_y, z - ur_z,
                0, 0,
                w, 0,
                w, h,
                0, h,
            }
        end

        obj.drawpoly(polys)
    end
end

local fan = layout == 0 and 2.0 * math.pi / (n + 1) or sweep / max(n, 1.0)
local valid, binorm_axis
if (align) then
    if (norm_axis ~= tan_axis) then
        valid = true
        binorm_axis = 9 - norm_axis - tan_axis
    else
        valid = false
        debug_print("Equal Axes")
    end
end

if (_G["STYLIZE_ARRAY"] == nil) then
    _G["STYLIZE_ARRAY"] = { { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 } }
end

local dst = {}
local src = _G["STYLIZE_ARRAY"]
local len = #src
if (central_axis == 1) then
    for i = 0, n do
        local angle = fan * (i + offset)
        local c, s = cos(angle), sin(angle)

        local t = { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, radius * c, radius * s }

        if (align) then
            if (valid) then
                local rot = { 1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c }
                for j = 1, 3 do
                    t[tan_axis + j] = rot[j + 6]
                    t[norm_axis + j] = rot[j + 3]
                    t[binorm_axis + j] = rot[j]
                end
            else
                table.move({ 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0 }, 1, 9, 1, t)
            end
        end

        local rand = randomize and not ((i == 0 and skip_f) or (i == n and skip_l))

        if (rand) then
            local x = (math.random() * 2.0 - 1.0) * x_ex
            local y = (math.random() * 2.0 - 1.0) * y_ex
            local z = (math.random() * 2.0 - 1.0) * z_ex
            local rx = (math.random() * 2.0 - 1.0) * rx_ex
            local ry = (math.random() * 2.0 - 1.0) * ry_ex
            local rz = (math.random() * 2.0 - 1.0) * rz_ex
            local sx = (1.0 - math.random() * sx_ex)
            local sy = (1.0 - math.random() * sy_ex)
            local sz = (1.0 - math.random() * sz_ex)
            sx = math.random() < fx and -sx or sx
            sy = math.random() < fy and -sy or sy
            sz = math.random() < fz and -sz or sz

            t = fk(t, totransform(x, y, z, rx, ry, rz, sx, sy, sz))
        end

        for j = 1, len do
            dst[#dst + 1] = fk(t, src[j])
        end
    end
elseif (central_axis == 2) then
    for i = 0, n do
        local angle = fan * (i + offset)
        local c, s = cos(angle), sin(angle)

        local t = { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, radius * s, 0.0, radius * c }

        if (align) then
            if (valid) then
                local rot = { c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c }
                for j = 1, 3 do
                    t[tan_axis + j] = rot[j]
                    t[norm_axis + j] = rot[j + 6]
                    t[binorm_axis + j] = rot[j + 3]
                end
            else
                table.move({ 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0 }, 1, 9, 1, t)
            end
        end

        local rand = randomize and not ((i == 0 and skip_f) or (i == n and skip_l))

        if (rand) then
            local x = (math.random() * 2.0 - 1.0) * x_ex
            local y = (math.random() * 2.0 - 1.0) * y_ex
            local z = (math.random() * 2.0 - 1.0) * z_ex
            local rx = (math.random() * 2.0 - 1.0) * rx_ex
            local ry = (math.random() * 2.0 - 1.0) * ry_ex
            local rz = (math.random() * 2.0 - 1.0) * rz_ex
            local sx = (1.0 - math.random() * sx_ex)
            local sy = (1.0 - math.random() * sy_ex)
            local sz = (1.0 - math.random() * sz_ex)
            sx = math.random() < fx and -sx or sx
            sy = math.random() < fy and -sy or sy
            sz = math.random() < fz and -sz or sz

            t = fk(t, totransform(x, y, z, rx, ry, rz, sx, sy, sz))
        end

        for j = 1, len do
            dst[#dst + 1] = fk(t, src[j])
        end
    end
else
    for i = 0, n do
        local angle = fan * (i + offset)
        local c, s = cos(angle), sin(angle)

        local t = { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, radius * c, radius * s, 0.0 }

        if (align) then
            if (valid) then
                local rot = { c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0 }
                for j = 1, 3 do
                    t[tan_axis + j] = rot[j + 3]
                    t[norm_axis + j] = rot[j]
                    t[binorm_axis + j] = rot[j + 6]
                end
            end
        end

        local rand = randomize and not ((i == 0 and skip_f) or (i == n and skip_l))

        if (rand) then
            local x = (math.random() * 2.0 - 1.0) * x_ex
            local y = (math.random() * 2.0 - 1.0) * y_ex
            local z = (math.random() * 2.0 - 1.0) * z_ex
            local rx = (math.random() * 2.0 - 1.0) * rx_ex
            local ry = (math.random() * 2.0 - 1.0) * ry_ex
            local rz = (math.random() * 2.0 - 1.0) * rz_ex
            local sx = (1.0 - math.random() * sx_ex)
            local sy = (1.0 - math.random() * sy_ex)
            local sz = (1.0 - math.random() * sz_ex)
            sx = math.random() < fx and -sx or sx
            sy = math.random() < fy and -sy or sy
            sz = math.random() < fz and -sz or sz

            t = fk(t, totransform(x, y, z, rx, ry, rz, sx, sy, sz))
        end

        for j = 1, len do
            dst[#dst + 1] = fk(t, src[j])
        end
    end
end

_G["STYLIZE_ARRAY"] = dst

if (not obj.getoption("script_name", 1, true):match("^Array(.*)${SCRIPT_NAME}$")) then
    obj.effect()

    local cx, cy, cz = obj.getvalue("cx") + obj.cx, obj.getvalue("cy") + obj.cy, obj.getvalue("cz") + obj.cz
    draw(_G["STYLIZE_ARRAY"], cx, cy, cz)

    _G["STYLIZE_ARRAY"] = nil
    obj.setoption("focus_mode", "fixed_size")
end
end


@GradientMap
--information:GradientMap${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--file@_1:Map File
--track0:Map Layer,-256,256,0,1
--check@_9:Use Relative Layer,0
--check0:View Map,0
--track@_2:Map Hue,-3600,3600,0,0.01
--track1:Map Slice,0,100,50,0.01
--track2:Map Scale,0,1000,100,0.01
--track3:Map Shift,-1000,1000,0,0.01
--select@_3:Map Edges,Clamp=0,Repeat=1,Mirror=2
--check@_4:Invert Luma,0
--select@_5:Luma Mode=1,BT.601=0,BT.709=1,BT.2020=2
--select@_6:Color Space=1,Linear=0,sRGB=1
--select@_7:Blend Mode,Normal=0,Add=1,Subtract=2,Multiply=3,Screen=4,Overlay=5,Lighten=6,Darken=7,Luminosity=8,Chroma=9,Linear Burn=10,Linear Light=11,Difference=12
--track@_8:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@gradient_map:
--#include "shaders/utils.hlsl"
--#include "shaders/map_utils.hlsl"
--#include "shaders/gradient_map.hlsl"
]]
--[[pixelshader@map_viewer:
--#include "shaders/utils.hlsl"
--#include "shaders/map_utils.hlsl"
--#include "shaders/map_viewer.hlsl"
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local map_path = _0.map_path and tostring(_0.map_path) or _1 _1 = nil
local map_layer = math.floor(tonumber(_0.map_layer) or obj.track0)
local use_rel_layer = _9 ~= 0 _9 = nil
if (type(_0.use_rel_layer) == "boolean") then
    use_rel_layer = _0.use_rel_layer
elseif (type(_0.use_rel_layer) == "number") then
    use_rel_layer = _0.use_rel_layer ~= 0
end
local view_map = obj.check0
if (type(_0.view_map) == "boolean") then
    view_map = _0.view_map
elseif (type(_0.view_map) == "number") then
    view_map = _0.view_map ~= 0
end
local map_hue = tonumber(_0.map_hue) or _2 _2 = nil
local map_slice = clamp(tonumber(_0.map_slice) or obj.track1, 0.0, 100.0) * 0.01
local map_scale = math.max(tonumber(_0.map_scale) or obj.track2, 0.0) * 0.01
local map_shift = tonumber(_0.map_shift) or obj.track3 * 0.01
local map_edges = tonumber(_0.map_edges) or _3 _3 = nil
local inv_luma = _4 _4 = nil
if (type(_0.inv_luma) == "boolean") then
    inv_luma = _0.inv_luma and 1 or 0
elseif (type(_0.inv_luma) == "number") then
    inv_luma = _0.inv_luma ~= 0 and 1 or 0
end
local luma_mode = tonumber(_0.luma_mode) or _5 _5 = nil
local col_space = tonumber(_0.col_space) or _6 _6 = nil
local blend_mode = tonumber(_0.blend_mode) or _7 _7 = nil
local mix = clamp(tonumber(_0.mix) or _8, 0.0, 100.0) * 0.01 _8= nil
_0 = nil

local function err_handler(e)
    local hint = "Hint: Try increasing TemporaryImageCacheSize in system.conf."
    debug_print(string.format("%s. %s", e, hint))
end

local function copy_geo(dst, src)
    for k in ("ox, oy, oz, cx, cy, cz, rx, ry, rz, zoom, aspect, alpha"):gmatch("%a+") do
        dst[k] = src[k]
    end
end

local ok, e = pcall(function()
local geo = {}
local map_w, map_h
local layer = use_rel_layer and math.max(obj.layer + map_layer, 1) or math.max(map_layer, 0)
if (map_path == "" and (layer == 0 or layer == obj.layer)) then
    debug_print("The map not found.")
    return
end

copy_geo(geo, obj)
obj.copybuffer("tempbuffer", "object")
obj.copybuffer("cache:img", "object")

if (layer == 0 or layer == obj.layer) then
    obj.load("image", map_path)
else
    obj.load("layer", layer, true)
end

map_w, map_h = obj.getpixel()
if (map_w * map_h < 1) then
    debug_print("The map size is invalid.")
    obj.load("tempbuffer")
    copy_geo(obj, geo)
    return
end

obj.effect("色調補正", "色相", map_hue)

if (view_map) then
    obj.pixelshader("map_viewer", "object", "object", {
        map_w, map_h,
        map_slice,
        map_scale,
        map_shift,
        map_edges,
    })
    copy_geo(obj, geo)
    return
end

obj.pixelshader("gradient_map", "cache:img", {"cache:img", "object"}, {
    map_w, map_h,
    map_slice,
    map_scale,
    map_shift,
    map_edges,
    inv_luma,
    luma_mode,
    col_space
})

obj.copybuffer("object", "cache:img")
obj.clearbuffer("cache:img")

obj.setoption("drawtarget", "tempbuffer")
obj.setoption("blend", blend_mode)
obj.draw(0, 0, 0, 1, mix)
obj.setoption("blend", 0)

obj.load("tempbuffer")
obj.clearbuffer("tempbuffer")
copy_geo(obj, geo)
end)
if (not ok) then
    err_handler(e)
end


@Unpremultiply
--information:Unpremultiply${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--track0:Gain,0,1000,100,0.01
--value@_0:PI,{}
--[[pixelshader@unpremult:
--#include "shaders/unpremult.hlsl"
]]

_0 = _0 or {}
local gain = math.max(tonumber(_0.gain) or obj.track0, 0.0) * 0.01
_0 = nil

obj.pixelshader("unpremult", "object", "object", {
    gain
})
