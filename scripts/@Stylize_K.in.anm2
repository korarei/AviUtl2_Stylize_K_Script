@Saturate
--information:Saturate${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--track0:R Gain,0,1000,100,0.01
--track1:G Gain,0,1000,100,0.01
--track2:B Gain,0,1000,100,0.01
--track3:A Gain,0,1000,100,0.01
--select@_1:Color Space=1,Linear=0,sRGB=1
--track@_2:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@saturate:
--#include "shaders/utils.hlsl"
--#include "shaders/saturate.hlsl"
]]

_0 = _0 or {}
local r_gain = math.max(tonumber(_0.r_gain) or obj.track0, 0.0) * 0.01
local g_gain = math.max(tonumber(_0.g_gain) or obj.track1, 0.0) * 0.01
local b_gain = math.max(tonumber(_0.b_gain) or obj.track2, 0.0) * 0.01
local a_gain = math.max(tonumber(_0.a_gain) or obj.track3, 0.0) * 0.01
local col_space = tonumber(_0.col_space) or _1 _1 = nil
local mix = math.max(math.min(tonumber(_0.mix) or _2, 100.0), 0.0) * 0.01 _2 = nil
_0 = nil

obj.pixelshader("saturate", "object", "object", {
    r_gain, g_gain, b_gain, a_gain,
    col_space,
    mix
})


@Mosaic
--information:Mosaic${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--track0:X Blocks,1,16384,32,1
--track1:Y Blocks,1,16384,32,1
--check0:Sharp Colors,0
--value@_0:PI,{}
--[[computeshader@mosaic_ave:
--#include "shaders/mosaic_ave.hlsl"
]]
--[[pixelshader@mosaic_draw:
--#include "shaders/mosaic_draw.hlsl"
]]
--[[pixelshader@mosaic_point:
--#include "shaders/mosaic_point.hlsl"
]]

_0 = _0 or {}
local bx = math.floor(tonumber(_0.bx) or obj.track0)
local by = math.floor(tonumber(_0.by) or obj.track1)
local sharp_col = obj.check0
if (type(_0.sharp_col) == "boolean") then
    sharp_col = _0.sharp_col
elseif (type(_0.sharp_col) == "number") then
    sharp_col = _0.sharp_col ~= 0
end
_0 = nil

local function err_handler(e)
    local hint = "Hint: Try increasing TemporaryImageCacheSize in system.conf."
    debug_print(string.format("%s. %s", e, hint))
end

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

local ok, e = pcall(function()
local w, h = obj.getpixel()
bx = clamp(bx, 1, w)
by = clamp(by, 1, h)

if (sharp_col) then
    obj.pixelshader("mosaic_point", "object", "object", {
        bx, by,
        w, h
    })
else
    local n = 256
    obj.setoption("drawtarget", "tempbuffer", bx, by)
    obj.computeshader("mosaic_ave", "tempbuffer", "object", {
        bx, by,
        w, h,
        n,
        bx * by
    },
    n, 1, 1)

    obj.pixelshader("mosaic_draw", "object", "tempbuffer", {
        bx, by,
        w, h
    })

    obj.clearbuffer("tempbuffer")
end
end)
if (not ok) then
    err_handler(e)
end


@Threshold
--information:Threshold${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--track0:Threshold,0,255,128
--select@_1:Channel=1,Luminance (BT.601)=0,Luminance (BT.709)=1,Luminance (BT.2020)=2,Value=3,Saturation=4,Hue=5,Alpha=6
--check0:Invert,0
--color@_2:Light Color,0xffffff
--track2:Light Alpha,0,100,100,0.01
--color@_3:Dark Color,0x000000
--track3:Dark Alpha,0,100,100,0.01
--select@_4:Color Space=1,Linear=0,sRGB=1
--track1:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@thresholding:
--#include "shaders/utils.hlsl"
--#include "shaders/threshold.hlsl"
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local threshold = clamp(tonumber(_0.threshold) or obj.track0, 0.0, 255.0) / 255.0
local channel = tonumber(_0.channel) or _1 _1 = nil
local inv = obj.check0 and 1 or 0
if (type(_0.inv) == "boolean") then
    inv = _0.inv and 1 or 0
elseif (type(_0.inv) == "boolean") then
    inv = _0.inv ~= 0 and 1 or 0
end
local light_col = clamp(tonumber(_0.light_col) or _2, 0x000000, 0xffffff) _2 = nil
local light_a = clamp(tonumber(_0.light_a) or obj.track2, 0.0, 100.0) * 0.01
local dark_col = clamp(tonumber(_0.dark_col) or _3, 0x000000, 0xffffff) _3 = nil
local dark_a = clamp(tonumber(_0.dark_a) or obj.track3, 0.0, 100.0) * 0.01
local col_space = tonumber(_0.col_space) or _4 _4 = nil
local mix = clamp(tonumber(_0.mix) or obj.track1, 0.0, 100.0) * 0.01
_0 = nil

obj.pixelshader("thresholding", "object", "object", {
    threshold,
    channel,
    inv,
    light_col,
    light_a,
    dark_col,
    dark_a,
    col_space,
    mix
})


@Threshold(RGBA)
--information:Threshold(RGBA)${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--track0:R Threshold,0,255,128
--track1:G Threshold,0,255,128
--track2:B Threshold,0,255,128
--track3:A Threshold,0,255,128
--check@_1:Invert R,0
--check@_2:Invert G,0
--check@_3:Invert B,0
--check@_4:Invert A,0
--check0:Disable A Threshold,0
--select@_5:Color Space=1,Linear=0,sRGB=1
--track@_6:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@thresholding_rgba:
--#include "shaders/utils.hlsl"
--#include "shaders/threshold_rgba.hlsl"
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local r_threshold = clamp(tonumber(_0.r_threshold) or obj.track0, 0.0, 255.0) / 255.0
local g_threshold = clamp(tonumber(_0.g_threshold) or obj.track1, 0.0, 255.0) / 255.0
local b_threshold = clamp(tonumber(_0.b_threshold) or obj.track2, 0.0, 255.0) / 255.0
local a_threshold = clamp(tonumber(_0.a_threshold) or obj.track3, 0.0, 255.0) / 255.0
local inv_r = _1 _1 = nil
if (type(_0.inv_r) == "boolean") then
    inv_r = _0.inv_r and 1 or 0
elseif (type(_0.inv_r) == "number") then
    inv_r = _0.inv_r ~= 0 and 1 or 0
end
local inv_g = _2 _2 = nil
if (type(_0.inv_g) == "boolean") then
    inv_g = _0.inv_g and 1 or 0
elseif (type(_0.inv_g) == "number") then
    inv_g = _0.inv_g ~= 0 and 1 or 0
end
local inv_b = _3 _3 = nil
if (type(_0.inv_b) == "boolean") then
    inv_b = _0.inv_b and 1 or 0
elseif (type(_0.inv_b) == "number") then
    inv_b = _0.inv_b ~= 0 and 1 or 0
end
local inv_a = _4 _4 = nil
if (type(_0.inv_a) == "boolean") then
    inv_a = _0.inv_a and 1 or 0
elseif (type(_0.inv_a) == "number") then
    inv_a = _0.inv_a ~= 0 and 1 or 0
end
local disable_a = obj.check0 and 1 or 0
if (type(_0.disable_a) == "boolean") then
    disable_a = _0.disable_a and 1 or 0
elseif (type(_0.disable_a) == "number") then
    disable_a = disable_a ~= 0 and 1 or 0
end
local col_space = tonumber(_0.col_space) or _5 _5 = nil
local mix = clamp(tonumber(_0.mix) or _6, 0.0, 100.0) * 0.01 _6 = nil
_0 = nil

obj.pixelshader("thresholding_rgba", "object", "object", {
    r_threshold, g_threshold, b_threshold, a_threshold,
    inv_r, inv_g, inv_b, inv_a,
    disable_a,
    col_space,
    mix
})


@Posterize
--information:Posterize${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--track0:Level,1,256,8,1
--select@_1:Channel,RGB=0,RGBA=1,Value=2,Value A=3
--track@_2:Size,1,2000,1,1
--check@_5:Sharp Colors,0
--select@_3:Color Space=1,Linear=0,sRGB=1
--track@_4:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@posterize:
--#include "shaders/utils.hlsl"
--#include "shaders/posterize.hlsl"
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local level = clamp(math.floor(tonumber(_0.level) or obj.track0), 1, 256)
local channel = tonumber(_0.channel) or _1 _1 = nil
local size = math.max(math.floor(tonumber(_0.size) or _2), 1) _2 = nil
local sharp_col = _5 _5 = nil
if (type(_0.sharp_col) == "boolean") then
    sharp_col = _0.sharp_col and 1 or 0
elseif (type(_0.sharp_col) == "number") then
    sharp_col = _0.sharp_col ~= 0 and 1 or 0
end
local col_space = tonumber(_0.col_space) or _3 _3 = nil
local mix = clamp(tonumber(_0.mix) or _4, 0.0, 100.0) * 0.01 _4 = nil
_0 = nil

if (size > 1) then
    local w, h = obj.getpixel()
    local mosaic_params = string.format("bx = %d, by = %d, sharp_col = %d", w / size, h / size, sharp_col)
    obj.effect("Mosaic@Stylize_K", "PI", mosaic_params)
end

obj.pixelshader("posterize", "object", "object", {
    level,
    channel,
    col_space,
    mix
})


@Posterize(RGBA)
--information:Posterize(RGBA)${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--track0:R Level,1,256,8,1
--track1:G Level,1,256,8,1
--track2:B Level,1,256,8,1
--track3:A Level,1,256,8,1
--check0:Disable A Level,0
--track@_1:Size,1,2000,1,1
--check@_2:Sharp Colors,0
--select@_3:Color Space=1,Linear=0,sRGB=1
--track@_4:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@posterize_rgba:
--#include "shaders/utils.hlsl"
--#include "shaders/posterize_rgba.hlsl"
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local r_level = clamp(math.floor(tonumber(_0.r_level) or obj.track0), 1, 256)
local g_level = clamp(math.floor(tonumber(_0.g_level) or obj.track1), 1, 256)
local b_level = clamp(math.floor(tonumber(_0.b_level) or obj.track2), 1, 256)
local a_level = clamp(math.floor(tonumber(_0.a_level) or obj.track3), 1, 256)
local disable_a = obj.check0 and 1 or 0
if (type(_0.disable_a) == "boolean") then
    disable_a = _0.disable_a and 1 or 0
elseif (type(_0.disable_a) == "number") then
    disable_a = disable_a ~= 0 and 1 or 0
end
local size = math.max(math.floor(tonumber(_0.size) or _1), 1) _1 = nil
local sharp_col = _2 _2 = nil
if (type(_0.sharp_col) == "boolean") then
    sharp_col = _0.sharp_col and 1 or 0
elseif (type(_0.sharp_col) == "number") then
    sharp_col = _0.sharp_col ~= 0 and 1 or 0
end
local col_space = tonumber(_0.col_space) or _3 _3 = nil
local mix = clamp(tonumber(_0.mix) or _4, 0.0, 100.0) * 0.01 _4 = nil
_0 = nil

if (size > 1) then
    local w, h = obj.getpixel()
    local mosaic_params = string.format("bx = %d, by = %d, sharp_col = %d", w / size, h / size, sharp_col)
    obj.effect("Mosaic@Stylize_K", "PI", mosaic_params)
end

obj.pixelshader("posterize_rgba", "object", "object", {
    r_level, g_level, b_level, a_level,
    disable_a,
    col_space,
    mix
})


@ASCII
--information:ASCII${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--value@_1:Glyphs,"@#%*+=-:. "
--font@_2:Font,Yu Gothic UI
--track@_3:Padding,-100,100,0,1
--track0:X Blocks,1,16384,80,1
--track1:Y Blocks,1,16384,45,1
--check0:Sharp Colors,0
--track@_4:Luma Gain,0,1000,100,0.01
--track2:Min Luma,0,100,0,0.01
--track3:Max Luma,0,100,100,0.01
--select@_5:Luma Mode=1,BT.601=0,BT.709=1,BT.2020=2
--check@_6:Invert Luma,1
--select@_7:Glyph Type=0,Solid=0,Original=1,Mosaic=2
--color@_8:Glyph Color,0xffffff
--select@_9:Canvas Type,Transparent=0,Solid=1,Original=2,Mosaic=3
--color@_10:Canvas Color,0x000000
--select@_11:Color Space=1,Linear=0,sRGB=1
--select@_12:Alpha,None=0,Premultiplied=1
--select@_13:Blend Mode,Normal=0,Add=1,Subtract=2,Multiply=3,Screen=4,Overlay=5,Lighten=6,Darken=7,Luminosity=8,Chroma=9,Linear Burn=10,Linear Light=11,Difference=12
--track@_14:Mix,0,100,100,0.01
--check@_15:Shuffle Glyphs,0
--value@_16:Excluded Glyphs,""
--track@_17:Interval,0,100,0,1
--track@_18:Seed,-1000,1000,-1,1
--value@_0:PI,{}
--[[pixelshader@ascii:
--#include "shaders/utils.hlsl"
--#include "shaders/ascii.hlsl"
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local glyphs_str = _0.glyphs and tostring(_0.glyphs) or _1 _1 = nil
local font = _0.font and tostring(_0.font) or _2 _2 = nil
local padding = math.floor(tonumber(_0.padding) or _3) _3 = nil
local bx = clamp(math.floor(tonumber(_0.bx) or obj.track0), 1, 16384)
local by = clamp(math.floor(tonumber(_0.by) or obj.track1), 1, 16384)
local sharp_col = obj.check0 and 1 or 0
if (type(_0.sharp_col) == "boolean") then
    sharp_col = _0.sharp_col and 1 or 0
elseif (type(_0.sharp_col) == "number") then
    sharp_col = _0.sharp_col ~= 0 and 1 or 0
end
local luma_gain = math.max(tonumber(_0.luma_gain) or _4, 0.0) * 0.01 _4 = nil
local min_luma = clamp(tonumber(_0.min_luma) or obj.track2, 0.0, 100.0) * 0.01
local max_luma = clamp(tonumber(_0.max_luma) or obj.track3, 0.0, 100.0) * 0.01
local luma_mode = tonumber(_0.luma_mode) or _5 _5 = nil
local inv_luma = _6 _6 = nil
if (type(_0.inv_luma) == "boolean") then
    inv_luma = _0.inv_luma and 1 or 0
elseif (type(_0.inv_luma) == "number") then
    inv_luma = _0.inv_luma ~= 0 and 1 or 0
end
local glyph_type = tonumber(_0.glyph_type) or _7 _7 = nil
local glyph_col = clamp(tonumber(_0.glyph_col) or _8, 0x000000, 0xffffff) _8 = nil
local canvas_type = tonumber(_0.canvas_type) or _9 _9 = nil
local canvas_col = clamp(tonumber(_0.canvas_col) or _10, 0x000000, 0xffffff) _10 = nil
local col_space = tonumber(_0.col_space) or _11 _11 = nil
local alpha = tonumber(_0.alpha) or _12 _12 = nil
local blend_mode = tonumber(_0.blend_mode) or _13 _13= nil
local mix = clamp(tonumber(_0.mix) or _14, 0.0, 100.0) * 0.01 _14 = nil
local shuf_glyphs = _15 ~= 0 _15 = nil
if (type(_0.shuf_glyphs) == "boolean") then
    shuf_glyphs = _0.shuf_glyphs
elseif (type(_0.shuf_glyphs) == "number") then
    shuf_glyphs = _0.inv_luma ~= 0
end
local exclude_str = _0.excluded_glyphs and tonumber(_0.excluded_glyphs) or _16 _16 = nil
local interval = math.max(tonumber(_0.interval) or _17, 0) _17 = nil
local seed = tonumber(_0.seed) or _18 _18 = nil
_0 = nil

if (glyphs_str == "") then
    debug_print("The text cannot be empty.")
    return
end

local function err_handler(e)
    local hint = "Hint: Try increasing TemporaryImageCacheSize in system.conf."
    debug_print(string.format("%s. %s", e, hint))
end

local function copy_geo(dst, src)
    for k in ("ox, oy, oz, cx, cy, cz, rx, ry, rz, zoom, aspect, alpha"):gmatch("%a+") do
        dst[k] = src[k]
    end
end

local function split_utf8(str)
    local t = {}
    local i = 1
    while i <= #str do
        local byte = string.byte(str, i)
        local len

        if (byte < 0x80) then
            len = 1
        elseif (byte < 0xE0) then
            len = 2
        elseif (byte < 0xF0) then
            len = 3
        else
            len = 4
        end

        table.insert(t, string.sub(str, i, i + len - 1))
        i = i + len
    end
    return t
end

local function shuffle(t, exclude)
    local set = {}
    for _, v in ipairs(exclude or {}) do
        set[v] = true
    end

    local indices = {}
    local len = 0
    for i = 1, #t do
        if not set[t[i]] then
            len = len + 1
            indices[len] = i
        end
    end

    local f = interval > 0 and math.floor(obj.frame / interval) or 0
    for i = len, 2, -1 do
        local j = obj.rand(1, i, seed, f)
        local m, n = indices[i], indices[j]
        t[m], t[n] = t[n], t[m]
    end
end

local ok, e = pcall(function()
    local geo = {}
    local blend = glyph_type == 1 and "mask" or "copy"
    local col_list = {0xff0000, 0x00ff00, 0x0000ff}
    local w, h = obj.getpixel()
    local max_w, max_h = obj.getinfo("image_max")
    local bw, bh = math.floor(w / bx), math.floor(h / by)
    local mosaic_params = string.format("bx = %d, by = %d, sharp_col = %d", bx, by, sharp_col)
    local size = math.max(math.min(bw, bh) - padding * 2, 0)
    local glyphs = split_utf8(glyphs_str)
    local exclude = split_utf8(exclude_str)
    local len = #glyphs
    local map_w, map_h = bw * math.ceil(len / 3.0), bh
    if (map_w > max_w or map_h > max_h) then
        debug_print("The font size is too large or the text is too long.")
        return
    end

    copy_geo(geo, obj)
    obj.copybuffer("cache:img", "object")
    obj.effect("Mosaic@Stylize_K", "PI", mosaic_params)
    obj.copybuffer("cache:mosaic", "object")

    obj.setoption("drawtarget", "tempbuffer", map_w, map_h)
    obj.setoption("blend", 1)
    if (shuf_glyphs) then
        shuffle(glyphs, exclude)
    end

    local a = -0.5 * (map_w - bw)
    for i = 1, len do
        local idx = i - 1
        obj.setfont(font, size, 0, col_list[(idx % 3) + 1])
        obj.load("text", glyphs[i])
        obj.draw(a + bw * (math.floor(idx / 3)))
    end

    obj.copybuffer("object", "cache:img")
    obj.pixelshader("ascii", "object", {
        "cache:mosaic",
        "tempbuffer"
    }, {
        bx, by,
        w, h,
        map_w, map_h,
        min_luma, max_luma,
        len,
        luma_gain,
        luma_mode,
        inv_luma,
        glyph_type,
        glyph_col,
        col_space,
        alpha
    }, blend)

    if (canvas_type == 1) then
        obj.setoption("drawtarget", "tempbuffer", w, h)
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")

        obj.copybuffer("cache:ascii", "object")
        obj.load("figure", "四角形", canvas_col, 1)
        local half_w, half_h = w * 0.5, h * 0.5
        obj.drawpoly(
            -half_w, -half_h, 0,
            half_w,  -half_h, 0,
            half_w,  half_h,  0,
            -half_w, half_h,  0
        )
        obj.copybuffer("object", "cache:ascii")
    elseif (canvas_type == 2) then
        obj.copybuffer("tempbuffer", "cache:img")
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")
    elseif (canvas_type == 3) then
        obj.copybuffer("tempbuffer", "cache:mosaic")
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")
    else
        obj.setoption("drawtarget", "tempbuffer", w, h)
        obj.clearbuffer("cache:img")
        obj.clearbuffer("cache:mosaic")
    end

    obj.setoption("blend", blend_mode)
    obj.draw(0, 0, 0, 1, mix)
    obj.setoption("blend", 0)

    obj.load("tempbuffer")
    obj.clearbuffer("tempbuffer")
    copy_geo(obj, geo)
end)
if (not ok) then
    err_handler(e)
end


@MotionTile
--information:MotionTile${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}\Tile
--track2:Width Scale,0,10000,100,0.01
--track3:Height Scale,0,10000,100,0.01
--select@s0:Mirror Direction,None=0,Horizontal=1,Vertical=2,Both=3
--group:Transform,false
--track0:X Center,-4000,4000,0,0.01
--track1:Y Center,-4000,4000,0,0.01
--track4:X Scale,0,10000,100,0.01
--track5:Y Scale,0,10000,100,0.01
--track6:Rotation,-3600,3600,0,0.01
--group:Phase Shift,false
--track7:Phase,-3600,3600,0,0.01
--select@s1:Phase Direction=1,Horizontal=0,Vertical=1
--group:Additional Options,false
--value@_0:PI,{}
--[[pixelshader@motion_tile:
--#include "shaders/motion_tile.hlsl"
]]

obj.setanchor("track", 0, "line")

_0 = _0 or {}
local sw = obj.track2
local sh = obj.track3
local sx = obj.track4
local sy = obj.track5

if (type(_0.scale) == "table") then
    sw = tonumber(_0.scale.w) or obj.track2
    sh = tonumber(_0.scale.h) or obj.track3
    sx = tonumber(_0.scale.x) or obj.track4
    sy = tonumber(_0.scale.y) or obj.track5
end

sw = sw * 0.01
sh = sh * 0.01
sx = sx * 0.01
sy = sy * 0.01

local cx = obj.track0
local cy = obj.track1

if (type(_0.center) == "table") then
    cx = tonumber(_0.center.x) or obj.track0
    cy = tonumber(_0.center.y) or obj.track1
end

cx = cx / obj.w
cy = cy / obj.h

local phase = obj.track7
local phase_dir = s1
if (type(_0.phase_shift) == "table") then
    phase = tonumber(_0.phase_shift.phase) or obj.track7
    phase_dir = tonumber(_0.phase_shift.direction) or s1
end
s1 = nil

local rot = math.rad(tonumber(_0.rotation) or obj.track6)
local mirror = tonumber(_0.mirror_direction) or s0 s0 = nil
_0 = nil

--#include "utils.lua"

local geo = {}
local max_w, max_h = obj.getinfo("image_max")
local w = math.min(math.floor(obj.w * sw), max_w)
local h = math.min(math.floor(obj.h * sh), max_h)

if (w * h < 1) then
    obj.effect("リサイズ", "拡大率", 0)
    return
end

sw = w / obj.w
sh = h / obj.h

local c = math.cos(rot)
local s = math.sin(rot)

copy_geo(geo, obj)
obj.setoption("drawtarget", "tempbuffer", w, h)

obj.pixelshader("motion_tile", "tempbuffer", "object", {
    c, -s, 0.0, 0.0,
    s,  c,
    sw * 0.5 + cx, sh * 0.5 + cy,
    sw, sh,
    sx, sy,
    bit.band(mirror, 1), bit.rshift(mirror, 1),
    1 - phase_dir, phase_dir,
    phase / 360.0,
    obj.h / obj.w
}, "copy", "clamp")

obj.load("tempbuffer")
obj.clearbuffer("tempbuffer")
copy_geo(obj, geo)


@Tile
--information:Tile${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}\Tile
--group:Count
--track0:X Count,1,1000,3,1
--track1:Y Count,1,1000,3,1
--track2:Z Count,1,1000,1,1
--group:Padding
--select@s0:Padding Mode,Relative=0,Absolute=1,Bounds=2
--track3:X Padding,-100000,100000,0,0.01
--track4:Y Padding,-100000,100000,0,0.01
--track5:Z Padding,-100000,100000,0,0.01
--group:Offset,false
--select@s1:Offset Mode,Relative=0,Absolute=1,Endpoint=2
--track6:X Offset,-100000,100000,0,0.01
--track7:Y Offset,-100000,100000,0,0.01
--track8:Z Offset,-100000,100000,0,0.01
--group:Alignment,false
--select@s4:X Axis=1,Minimum=0,Center=1,Maximum=2
--select@s5:Y Axis=1,Minimum=0,Center=1,Maximum=2
--select@s6:Z Axis=1,Minimum=0,Center=1,Maximum=2
--group:Additional Options,false
--select@s7:Coord Space=1,World=0,Local=1
--value@_0:PI,{}

_0 = _0 or {}
local count = {
    x = obj.track0 - 1,
    y = obj.track1 - 1,
    z = obj.track2 - 1
}

if (type(_0.count) == "table") then
    count.x = (tonumber(_0.count.x) or obj.track0) - 1
    count.y = (tonumber(_0.count.y) or obj.track1) - 1
    count.z = (tonumber(_0.count.z) or obj.track2) - 1
end

local padding = {
    mode = s0,
    x = obj.track3,
    y = obj.track4,
    z = obj.track5
}

if (type(_0.padding) == "table") then
    padding.mode = tonumber(_0.padding.mode) or s0
    padding.x = tonumber(_0.padding.x) or obj.track3
    padding.y = tonumber(_0.padding.y) or obj.track4
    padding.z = tonumber(_0.padding.z) or obj.track5
end
s0 = nil

local offset = {
    mode = s1,
    x = obj.track6,
    y = obj.track7,
    z = obj.track8
}

if (type(_0.offset) == "table") then
    offset.mode = tonumber(_0.offset.mode) or s1
    offset.x = tonumber(_0.offset.x) or obj.track6
    offset.y = tonumber(_0.offset.y) or obj.track7
    offset.z = tonumber(_0.offset.z) or obj.track8
end
s1 = nil

local align = {
    x = s4,
    y = s5,
    z = s6
}

if (type(_0.alignment) == "table") then
    align.x = tonumber(_0.alignment.x) or s4
    align.y = tonumber(_0.alignment.y) or s5
    align.z = tonumber(_0.alignment.z) or s6
end
s4 = nil
s5 = nil
s6 = nil

local size = {
    x = obj.w,
    y = obj.h,
    z = 0.0
}

if (type(_0.size) == "table") then
    size.x = tonumber(_0.size.x) or obj.w
    size.y = tonumber(_0.size.y) or obj.h
    size.z = tonumber(_0.size.z) or 0.0
end

local space = tonumber(_0.coord_space) or s7 s7 = nil
_0 = nil

if (space == 0) then
    size.x = size.x * obj.getvalue("sx") * obj.sx
    size.y = size.y * obj.getvalue("sy") * obj.sy
    size.z = size.z * obj.getvalue("sz") * obj.sz
end

local d = {}
if (padding.mode == 0) then
    d.x = size.x * (1.0 + padding.x * 0.01)
    d.y = size.y * (1.0 + padding.y * 0.01)
    d.z = size.z * (1.0 + padding.z * 0.01)
elseif (padding.mode == 2) then
    d.x = (padding.x - size.x) / math.max(count.x, 1.0)
    d.y = (padding.y - size.y) / math.max(count.y, 1.0)
    d.z = (padding.z - size.z) / math.max(count.z, 1.0)
else
    d.x = size.x + padding.x
    d.y = size.y + padding.y
    d.z = size.z + padding.z
end

local o = {}
if (offset.mode == 0) then
    o.x = size.x * (offset.x * 0.01)
    o.y = size.y * (offset.y * 0.01)
    o.z = size.z * (offset.z * 0.01)
elseif (offset.mode == 2) then
    o.x = offset.x / math.max(count.y + count.z, 1.0)
    o.y = offset.y / math.max(count.z + count.x, 1.0)
    o.z = offset.z / math.max(count.x + count.y, 1.0)
else
    o.x = offset.x
    o.y = offset.y
    o.z = offset.z
end

local a = {
    x = -align.x * (0.5 * d.x * count.x + o.x),
    y = -align.y * (0.5 * d.y * count.y + o.y),
    z = -align.z * (0.5 * d.z * count.z + o.z)
}

obj.effect()
if (space == 1) then
    local polys = {}
    local pivot = {
        x = obj.w * 0.5,
        y = obj.h * 0.5
    }

    for k = 0, count.z do
        local z = a.z + d.z * k

        for i = 0, count.x do
            local x = a.x + d.x * i

            for j = 0, count.y do
                local y = a.y + d.y * j

                local ox = x + o.x * (j + k)
                local oy = y + o.y * (k + i)
                local oz = z + o.z * (i + j)

                local l = ox - pivot.x
                local r = ox + pivot.x
                local t = oy - pivot.y
                local b = oy + pivot.y

                table.insert(polys, {
                    l, t, oz,
                    r, t, oz,
                    r, b, oz,
                    l, b, oz,
                    0,     0,
                    obj.w, 0,
                    obj.w, obj.h,
                    0,     obj.h
                })
            end
        end
    end

    obj.drawpoly(polys)
else
    for k = 0, count.z do
        local z = a.z + d.z * k

        for i = 0, count.x do
            local x = a.x + d.x * i

            for j = 0, count.y do
                local y = a.y + d.y * j

                local ox = x + o.x * (j + k)
                local oy = y + o.y * (k + i)
                local oz = z + o.z * (i + j)

                obj.draw(ox, oy, oz)
            end
        end
    end
end


@Repeat
--information:Repeat${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}\Tile
--track@count:Count,1,1000,3,1
--track2:Offset,-1000,1000,0,0.1
--select@s0:Composite,Below=0,Above=1
--group:Transform Offset
--select@s1:Offset Mode,Relative=0,Absolute=1,Endpoint=2
--track3:X,-100000,100000,100,0.01
--track4:Y,-100000,100000,0,0.01
--track5:X Scale,0,10000,100,0.01
--track6:Y Scale,0,10000,100,0.01
--track7:Rotation,-3600,3600,0,0.01
--track8:Opacity,0,100,100,0.01
--group
--track0:X Center,-100000,100000,0,0.01
--track1:Y Center,-100000,100000,0,0.01
--select@s2:Blend Mode,Normal=0,Add=1,Subtract=2,Multiply=3,Screen=4,Overlay=5,Lighten=6,Darken=7,Luminosity=8,Color=9,Linear Burn=10,Linear Light=11,Difference=12
--group:Additional Options,false
--value@_0:PI,{}

obj.setanchor("track", 0, "line")

_0 = _0 or {}
local n = math.max(math.floor(tonumber(_0.count) or count), 1) - 1 count = nil -- for user
local offset = tonumber(_0.offset) or obj.track2
local composite = tonumber(_0.composite) or s0 s0 = nil
local cx = tonumber(_0.cx) or obj.track0
local cy = tonumber(_0.cy) or obj.track1
local offset_mode = tonumber(_0.offset_mode) or s1 s1 = nil
local x = tonumber(_0.x) or obj.track3
local y = tonumber(_0.y) or obj.track4
local sx = (tonumber(_0.sx) or obj.track5) * 0.01
local sy = (tonumber(_0.sy) or obj.track6) * 0.01
local rz = math.rad(tonumber(_0.rotation) or obj.track7)
local a = tonumber(_0.opacity) or obj.track8 * 0.01
local blend = tonumber(_0.blend_mode) or s2 s2 = nil
_0 = nil

local function draw(x_, y_, sx_, sy_, rz_, a_)
    local hw, hh = obj.w * sx_ * 0.5, obj.h * sy_ * 0.5
    local px, py = -cx * sx_, -cy * sy_

    local l = px - hw
    local r = px + hw
    local t = py - hh
    local b = py + hh

    local x0, y0, x1, y1, x2, y2, x3, y3 = rotation(l, t, r, t, r, b, l, b, 1.0, math.deg(rz_))
    local dx, dy = x_ + cx, y_ + cy

    obj.drawpoly(
        x0 + dx, y0 + dy, 0.0,
        x1 + dx, y1 + dy, 0.0,
        x2 + dx, y2 + dy, 0.0,
        x3 + dx, y3 + dy, 0.0,
        0,     0,
        obj.w, 0,
        obj.w, obj.h,
        0,     obj.h,
        a_
    )
end

local function resize(xforms)
    local t, r, b, l = -math.huge, -math.huge, -math.huge, -math.huge
    local len = #xforms
    for i = 1, len do
        local xform = xforms[i]
        local c0, s0 = math.cos(xform.rz), math.sin(xform.rz)
        local c1, s1 = math.abs(c0), math.abs(s0)
        local tx, ty = -cx * xform.sx, -cy * xform.sy
        local w, h = obj.w * xform.sx, obj.h * xform.sy
        tx, ty = (c0 * tx - s0 * ty) + xform.x + cx, (s0 * tx + c0 * ty) + xform.y + cy
        w, h = c1 * w + s1 * h, s1 * w + c1 * h
        local dx, dy = (w - obj.w) * 0.5, (h - obj.h) * 0.5
        t = math.max(math.ceil(dy - ty), t)
        r = math.max(math.ceil(dx + tx), r)
        b = math.max(math.ceil(dy + ty), b)
        l = math.max(math.ceil(dx - tx), l)
    end
    return t, r, b, l
end

local function copy_geo(dst, src)
    for k in ("cx, cy, cz, ox, oy, oz, rx, ry, rz, sx, sy, sz, alpha"):gmatch("%a+") do
        dst[k] = src[k]
    end
end

local geo = {}
local xforms = {}
local st, ed, step = offset, n + offset, 1
if (composite == 0) then
    st, ed, step = ed, st, -1
end

if (offset_mode == 0) then
    x, y = obj.w * x * 0.01, obj.h * y * 0.01
elseif (offset_mode == 2 and n > 0) then
    local rn = 1.0 / n
    x, y, rz = x / n, y / n, rz / n
    sx, sy, a = sx ^ rn, sy ^ rn, a ^ rn
end

for i = st, ed, step do
    xforms[#xforms + 1] = {
        x = x * i,
        y = y * i,
        sx = sx ^ i,
        sy = sy ^ i,
        rz = rz * i,
        a = math.min(a ^ i, 1.0)
    }
end

local t, r, b, l = resize(xforms)
local dx, dy = (l - r) * 0.5, (t - b) * 0.5

copy_geo(geo, obj)
obj.setoption("drawtarget", "tempbuffer", obj.w + l + r, obj.h + t + b)
obj.setoption("blend", blend)

local len = #xforms
for i = 1, len do
    local xform = xforms[i]
    draw(xform.x + dx, xform.y + dy, xform.sx, xform.sy, xform.rz, xform.a)
end

obj.load("tempbuffer")
obj.clearbuffer("tempbuffer")
obj.setoption("blend", "none")
copy_geo(obj, geo)
obj.cx, obj.cy = obj.cx + dx, obj.cy + dy


@Array(Line)
--information:Array(Line)${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}\Tile\Array
--track@count:Count,1,1000,3,1
--group:Transform Offset
--select@s0:Offset Mode,Relative=0,Absolute=1,Endpoint=2
--track0:X,-100000,100000,100,0.01
--track1:Y,-100000,100000,0,0.01
--track2:Z,-100000,100000,0,0.01
--track3:X Rotation,-3600,3600,0,0.01
--track4:Y Rotation,-3600,3600,0,0.01
--track5:Z Rotation,-3600,3600,0,0.01
--track6:X Scale,0,10000,100,0.01
--track7:Y Scale,0,10000,100,0.01
--track8:Z Scale,0,10000,100,0.01
--group:Additional Options,false
--value@_0:PI,{}

_0 = _0 or {}
local n = math.max(math.floor(tonumber(_0.count) or count), 1) - 1 count = nil -- for user
local offset_mode = tonumber(_0.offset_mode) or s0 s0 = nil
local x = tonumber(_0.x) or obj.track0
local y = tonumber(_0.y) or obj.track1
local z = tonumber(_0.z) or obj.track2
local rx = math.rad(tonumber(_0.rx) or obj.track3)
local ry = math.rad(tonumber(_0.ry) or obj.track4)
local rz = math.rad(tonumber(_0.rz) or obj.track5)
local sx = (tonumber(_0.sx) or obj.track6) * 0.01
local sy = (tonumber(_0.sy) or obj.track7) * 0.01
local sz = (tonumber(_0.sz) or obj.track8) * 0.01
_0 = nil

local cx, cy, cz = obj.getvalue("cx") + obj.cx, obj.getvalue("cy") + obj.cy, obj.getvalue("cz") + obj.cz

local function rotate(rx_, ry_, rz_, ...)
    local c0, s0 = math.cos(rx_), math.sin(rx_)
    local c1, s1 = math.cos(ry_), math.sin(ry_)
    local c2, s2 = math.cos(rz_), math.sin(rz_)

    local m00 = c1 * c2
    local m01 = -c1 * s2
    local m02 = s1
    local m10 = s0 * s1 * c2 + c0 * s2
    local m11 = -s0 * s1 * s2 + c0 * c2
    local m12 = -s0 * c1
    local m20 = -c0 * s1 * c2 + s0 * s2
    local m21 = c0 * s1 * s2 + s0 * c2
    local m22 = c0 * c1

    local count = select("#", ...)
    for i = 1, count do
        local v = select(i, ...)
        local vx, vy, vz = v.x, v.y, v.z
        v.x = m00 * vx + m01 * vy + m02 * vz
        v.y = m10 * vx + m11 * vy + m12 * vz
        v.z = m20 * vx + m21 * vy + m22 * vz
    end
end

local function draw(xforms)
    local len = #xforms
    local polys = {}
    for i = 1, len do
        local xform = xforms[i]
        local hw, hh = obj.w * xform.sx * 0.5, obj.h * xform.sy * 0.5
        local px, py, pz = -cx * xform.sx, -cy * xform.sy, -cz * xform.sz

        local l = px - hw
        local r = px + hw
        local t = py - hh
        local b = py + hh

        local dx, dy, dz = xform.x + cx, xform.y + cy, xform.z + cz
        local v0 = { x = l, y = t, z = pz }
        local v1 = { x = r, y = t, z = pz }
        local v2 = { x = r, y = b, z = pz }
        local v3 = { x = l, y = b, z = pz }
        rotate(xform.rx, xform.ry, xform.rz, v0, v1, v2, v3)

        polys[#polys + 1] = {
            v0.x + dx, v0.y + dy, v0.z + dz,
            v1.x + dx, v1.y + dy, v1.z + dz,
            v2.x + dx, v2.y + dy, v2.z + dz,
            v3.x + dx, v3.y + dy, v3.z + dz,
            0,     0,
            obj.w, 0,
            obj.w, obj.h,
            0,     obj.h,
        }
    end

    obj.drawpoly(polys)
end

if (offset_mode == 0) then
    x, y, z = obj.w * x * 0.01, obj.h * y * 0.01, 0.0
elseif (offset_mode == 2 and n > 0) then
    local rn = 1.0 / n
    x, y, z = x / n, y / n, z / n
    rx, ry, rz = rx / n, ry / n, rz / n
    sx, sy, sz = sx ^ rn, sy ^ rn, sz ^ rn
end

if (_G["STYLIZE_ARRAY"] == nil) then
    _G["STYLIZE_ARRAY"] = { { x = 0.0, y = 0.0, z = 0.0, rx = 0.0, ry = 0.0, rz = 0.0, sx = 1.0, sy = 1.0, sz = 1.0 } }
end

local xforms = _G["STYLIZE_ARRAY"]
local len = #xforms
for i = 1, len do
    local xform = xforms[i]
    for j = 1, n do
        xforms[#xforms + 1] = {
            x = xform.x + x * j,
            y = xform.y + y * j,
            z = xform.z + z * j,
            rx = xform.rx + rx * j,
            ry = xform.ry + ry * j,
            rz = xform.rz + rz * j,
            sx = xform.sx * sx ^ j,
            sy = xform.sy * sy ^ j,
            sz = xform.sz * sz ^ j
        }
    end
end

if (not obj.getoption("script_name", 1, true):match("^Array(.*)${SCRIPT_NAME}$")) then
    obj.effect()
    draw(xforms)
    _G["STYLIZE_ARRAY"] = nil
    obj.setoption("focus_mode", "fixed_size")
end


@Array(Circle)
--information:Array(Circle)${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}\Tile\Array
--track@count:Count,1,1000,3,1
--group:Placement
--select@s0:Layout,Circle=0,Arc=2
--track0:Radius,0,100000,0,0.01
--track1:Start Angle,-3600,3600,0,0.01
--track2:Sweep Angle,0,360,360,0.01
--select@s1:Central Axis=2,X=0,Y=1,Z=2
--group
--check0:Align Rotation,1
--group:Additional Options,false
--value@_0:PI,{}

local function tobool(v, d)
    if (type(v) == "boolean") then
        return v
    elseif (type(v) == "number") then
        return v ~= 0
    else
        return d
    end
end

_0 = _0 or {}
local n = math.max(math.floor(tonumber(_0.count) or count), 1) - 1 count = nil -- for user
local layout = tonumber(_0.layout) or s0 s0 = nil
local radius = tonumber(_0.radius) or obj.track0
local start = math.rad(tonumber(_0.start_angle) or obj.track1)
local sweep = math.rad(tonumber(_0.sweep_angle) or obj.track2)
local central_axis = tonumber(_0.central_axis) or s1 s1 = nil
local align = tobool(_0.align_rotation, obj.check0)
_0 = nil

local cx, cy, cz = obj.getvalue("cx") + obj.cx, obj.getvalue("cy") + obj.cy, obj.getvalue("cz") + obj.cz

local function rotate(rx_, ry_, rz_, ...)
    local c0, s0 = math.cos(rx_), math.sin(rx_)
    local c1, s1 = math.cos(ry_), math.sin(ry_)
    local c2, s2 = math.cos(rz_), math.sin(rz_)

    local m00 = c1 * c2
    local m01 = -c1 * s2
    local m02 = s1
    local m10 = s0 * s1 * c2 + c0 * s2
    local m11 = -s0 * s1 * s2 + c0 * c2
    local m12 = -s0 * c1
    local m20 = -c0 * s1 * c2 + s0 * s2
    local m21 = c0 * s1 * s2 + s0 * c2
    local m22 = c0 * c1

    local count = select("#", ...)
    for i = 1, count do
        local v = select(i, ...)
        local vx, vy, vz = v.x, v.y, v.z
        v.x = m00 * vx + m01 * vy + m02 * vz
        v.y = m10 * vx + m11 * vy + m12 * vz
        v.z = m20 * vx + m21 * vy + m22 * vz
    end
end

local function draw(xforms)
    local len = #xforms
    local polys = {}
    for i = 1, len do
        local xform = xforms[i]
        local hw, hh = obj.w * xform.sx * 0.5, obj.h * xform.sy * 0.5
        local px, py, pz = -cx * xform.sx, -cy * xform.sy, -cz * xform.sz

        local l = px - hw
        local r = px + hw
        local t = py - hh
        local b = py + hh

        local dx, dy, dz = xform.x + cx, xform.y + cy, xform.z + cz
        local v0 = { x = l, y = t, z = pz }
        local v1 = { x = r, y = t, z = pz }
        local v2 = { x = r, y = b, z = pz }
        local v3 = { x = l, y = b, z = pz }
        rotate(xform.rx, xform.ry, xform.rz, v0, v1, v2, v3)

        polys[#polys + 1] = {
            v0.x + dx, v0.y + dy, v0.z + dz,
            v1.x + dx, v1.y + dy, v1.z + dz,
            v2.x + dx, v2.y + dy, v2.z + dz,
            v3.x + dx, v3.y + dy, v3.z + dz,
            0,     0,
            obj.w, 0,
            obj.w, obj.h,
            0,     obj.h,
        }
    end

    obj.drawpoly(polys)
end

local fan = layout == 0 and 2.0 * math.pi / (n + 1) or sweep / math.max(n, 1.0)
local r90 = math.pi * 0.5

if (_G["STYLIZE_ARRAY"] == nil) then
    _G["STYLIZE_ARRAY"] = { { x = 0.0, y = 0.0, z = 0.0, rx = 0.0, ry = 0.0, rz = 0.0, sx = 1.0, sy = 1.0, sz = 1.0 } }
end

local xforms = _G["STYLIZE_ARRAY"]
local len = #xforms
if (central_axis == 0) then
    for i = 1, len do
        local xform = xforms[i]

        local v0 = { x = xform.x, y = xform.y, z = xform.z }
        rotate(0.0, r90, r90, v0)
        xform.x, xform.y, xform.z = v0.x, v0.y, v0.z

        local c0, s0 = math.cos(start), math.sin(start)
        local y0, z0 = xform.y, xform.z
        xform.y = c0 * y0 - s0 * z0 + radius * c0
        xform.z = s0 * y0 + c0 * z0 + radius * s0
        if (align) then
            xform.rx = xform.rx + start
            xform.ry = xform.ry + r90
            xform.rz = xform.rz + r90
        end

        for j = 1, n do
            local angle = fan * j
            local c, s = math.cos(angle), math.sin(angle)
            xforms[#xforms + 1] = {
                x = xform.x,
                y = c * xform.y - s * xform.z,
                z = s * xform.y + c * xform.z,
                rx = xform.rx + (align and angle or 0.0),
                ry = xform.ry,
                rz = xform.rz,
                sx = xform.sx,
                sy = xform.sy,
                sz = xform.sz
            }
        end
    end
elseif (central_axis == 1) then
    for i = 1, len do
        local xform = xforms[i]

        local v0 = { x = xform.x, y = xform.y, z = xform.z }
        rotate(-r90, 0.0, -r90, v0)
        xform.x, xform.y, xform.z = v0.x, v0.y, v0.z

        local c0, s0 = math.cos(start), math.sin(start)
        local z0, x0 = xform.z, xform.x
        xform.z = c0 * z0 - s0 * x0 + radius * c0
        xform.x = s0 * z0 + c0 * x0 + radius * s0
        if (align) then
            xform.rx = xform.rx - r90
            xform.rz = xform.rz - r90 + start
        end

        for j = 1, n do
            local angle = fan * j
            local c, s = math.cos(angle), math.sin(angle)
            xforms[#xforms + 1] = {
                x = s * xform.z + c * xform.x,
                y = xform.y,
                z = c * xform.z - s * xform.x,
                rx = xform.rx,
                ry = xform.ry,
                rz = xform.rz + (align and angle or 0.0),
                sx = xform.sx,
                sy = xform.sy,
                sz = xform.sz
            }
        end
    end
else
    for i = 1, len do
        local xform = xforms[i]

        local c0, s0 = math.cos(start), math.sin(start)
        local x0, y0 = xform.x, xform.y
        xform.x = c0 * x0 - s0 * y0 + radius * c0
        xform.y = s0 * x0 + c0 * y0 + radius * s0
        if (align) then
            xform.rz = xform.rz + start
        end

        for j = 1, n do
            local angle = fan * j
            local c, s = math.cos(angle), math.sin(angle)
            xforms[#xforms + 1] = {
                x = c * xform.x - s * xform.y,
                y = s * xform.x + c * xform.y,
                z = xform.z,
                rx = xform.rx,
                ry = xform.ry,
                rz = xform.rz + (align and angle or 0.0),
                sx = xform.sx,
                sy = xform.sy,
                sz = xform.sz
            }
        end
    end
end

if (not obj.getoption("script_name", 1, true):match("^Array(.*)${SCRIPT_NAME}$")) then
    obj.effect()
    draw(xforms)
    _G["STYLIZE_ARRAY"] = nil
    obj.setoption("focus_mode", "fixed_size")
end


@GradientMap
--information:GradientMap${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--file@_1:Map File
--track0:Map Layer,-256,256,0,1
--check@_9:Use Relative Layer,0
--check0:View Map,0
--track@_2:Map Hue,-3600,3600,0,0.01
--track1:Map Slice,0,100,50,0.01
--track2:Map Scale,0,1000,100,0.01
--track3:Map Shift,-1000,1000,0,0.01
--select@_3:Map Edges,Clamp=0,Repeat=1,Mirror=2
--check@_4:Invert Luma,0
--select@_5:Luma Mode=1,BT.601=0,BT.709=1,BT.2020=2
--select@_6:Color Space=1,Linear=0,sRGB=1
--select@_7:Blend Mode,Normal=0,Add=1,Subtract=2,Multiply=3,Screen=4,Overlay=5,Lighten=6,Darken=7,Luminosity=8,Chroma=9,Linear Burn=10,Linear Light=11,Difference=12
--track@_8:Mix,0,100,100,0.01
--value@_0:PI,{}
--[[pixelshader@gradient_map:
--#include "shaders/utils.hlsl"
--#include "shaders/map_utils.hlsl"
--#include "shaders/gradient_map.hlsl"
]]
--[[pixelshader@map_viewer:
--#include "shaders/utils.hlsl"
--#include "shaders/map_utils.hlsl"
--#include "shaders/map_viewer.hlsl"
]]

local function clamp(v, min, max)
    return math.max(math.min(v, max), min)
end

_0 = _0 or {}
local map_path = _0.map_path and tostring(_0.map_path) or _1 _1 = nil
local map_layer = math.floor(tonumber(_0.map_layer) or obj.track0)
local use_rel_layer = _9 ~= 0 _9 = nil
if (type(_0.use_rel_layer) == "boolean") then
    use_rel_layer = _0.use_rel_layer
elseif (type(_0.use_rel_layer) == "number") then
    use_rel_layer = _0.use_rel_layer ~= 0
end
local view_map = obj.check0
if (type(_0.view_map) == "boolean") then
    view_map = _0.view_map
elseif (type(_0.view_map) == "number") then
    view_map = _0.view_map ~= 0
end
local map_hue = tonumber(_0.map_hue) or _2 _2 = nil
local map_slice = clamp(tonumber(_0.map_slice) or obj.track1, 0.0, 100.0) * 0.01
local map_scale = math.max(tonumber(_0.map_scale) or obj.track2, 0.0) * 0.01
local map_shift = tonumber(_0.map_shift) or obj.track3 * 0.01
local map_edges = tonumber(_0.map_edges) or _3 _3 = nil
local inv_luma = _4 _4 = nil
if (type(_0.inv_luma) == "boolean") then
    inv_luma = _0.inv_luma and 1 or 0
elseif (type(_0.inv_luma) == "number") then
    inv_luma = _0.inv_luma ~= 0 and 1 or 0
end
local luma_mode = tonumber(_0.luma_mode) or _5 _5 = nil
local col_space = tonumber(_0.col_space) or _6 _6 = nil
local blend_mode = tonumber(_0.blend_mode) or _7 _7 = nil
local mix = clamp(tonumber(_0.mix) or _8, 0.0, 100.0) * 0.01 _8= nil
_0 = nil

local function err_handler(e)
    local hint = "Hint: Try increasing TemporaryImageCacheSize in system.conf."
    debug_print(string.format("%s. %s", e, hint))
end

local function copy_geo(dst, src)
    for k in ("ox, oy, oz, cx, cy, cz, rx, ry, rz, zoom, aspect, alpha"):gmatch("%a+") do
        dst[k] = src[k]
    end
end

local ok, e = pcall(function()
local geo = {}
local map_w, map_h
local layer = use_rel_layer and math.max(obj.layer + map_layer, 1) or math.max(map_layer, 0)
if (map_path == "" and (layer == 0 or layer == obj.layer)) then
    debug_print("The map not found.")
    return
end

copy_geo(geo, obj)
obj.copybuffer("tempbuffer", "object")
obj.copybuffer("cache:img", "object")

if (layer == 0 or layer == obj.layer) then
    obj.load("image", map_path)
else
    obj.load("layer", layer, true)
end

map_w, map_h = obj.getpixel()
if (map_w * map_h < 1) then
    debug_print("The map size is invalid.")
    obj.load("tempbuffer")
    copy_geo(obj, geo)
    return
end

obj.effect("色調補正", "色相", map_hue)

if (view_map) then
    obj.pixelshader("map_viewer", "object", "object", {
        map_w, map_h,
        map_slice,
        map_scale,
        map_shift,
        map_edges,
    })
    copy_geo(obj, geo)
    return
end

obj.pixelshader("gradient_map", "cache:img", {"cache:img", "object"}, {
    map_w, map_h,
    map_slice,
    map_scale,
    map_shift,
    map_edges,
    inv_luma,
    luma_mode,
    col_space
})

obj.copybuffer("object", "cache:img")
obj.clearbuffer("cache:img")

obj.setoption("drawtarget", "tempbuffer")
obj.setoption("blend", blend_mode)
obj.draw(0, 0, 0, 1, mix)
obj.setoption("blend", 0)

obj.load("tempbuffer")
obj.clearbuffer("tempbuffer")
copy_geo(obj, geo)
end)
if (not ok) then
    err_handler(e)
end


@Unpremultiply
--information:Unpremultiply${SCRIPT_NAME} ${VERSION} by ${AUTHOR}
--label:${LABEL}
--track0:Gain,0,1000,100,0.01
--value@_0:PI,{}
--[[pixelshader@unpremult:
--#include "shaders/unpremult.hlsl"
]]

_0 = _0 or {}
local gain = math.max(tonumber(_0.gain) or obj.track0, 0.0) * 0.01
_0 = nil

obj.pixelshader("unpremult", "object", "object", {
    gain
})
